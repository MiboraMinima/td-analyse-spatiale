[
  {
    "objectID": "ressources/stats/stats.html",
    "href": "ressources/stats/stats.html",
    "title": "5  Statistiques",
    "section": "",
    "text": "5.1 Statistiques univariées",
    "crumbs": [
      "Traitements et analyse de données",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Statistiques</span>"
    ]
  },
  {
    "objectID": "ressources/stats/stats.html#statistiques-univariées",
    "href": "ressources/stats/stats.html#statistiques-univariées",
    "title": "5  Statistiques",
    "section": "",
    "text": "5.1.1 Variable quantitative\nLe tableau ci-dessous récapitule les indicateurs statistiques les plus courrament employés en analyse de données.\n\n\n\n\n\n\n\n\nStatistique\nFormule mathématique\nFonction R\n\n\n\n\nMoyenne\n\\(\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i\\)\nmean(x)\n\n\nMédiane\nValeur centrale de l’échantillon trié\nmedian(x)\n\n\nVariance\n\\(\\sigma^2 = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_i - \\bar{x})^2\\)\nvar(x)\n\n\nÉcart-type\n\\(\\sigma = \\sqrt{\\sigma^2}\\)\nsd(x)\n\n\nMinimum\n\\(\\min(x_1, \\dots, x_n)\\)\nmin(x)\n\n\nMaximum\n\\(\\max(x_1, \\dots, x_n)\\)\nmax(x)\n\n\nAmplitude (étendue)\n\\(\\max(x) - \\min(x)\\)\nrange(x) ou diff(range(x))\n\n\nSomme\n\\(\\sum_{i=1}^{n} x_i\\)\nsum(x)\n\n\nNombre d’observations\n\\(n\\)\nlength(x)\n\n\nQuantiles\n\\(Q_p\\) tel que \\(P(X \\le Q_p) = p\\)\nquantile(x, probs = p)\n\n\nCoefficient de variation\n\\(CV = \\frac{\\sigma}{\\bar{x}}\\)\nsd(x) / mean(x)\n\n\n\nOn peut récupérer un résumé statistiques basique d’un vecteur numérique avec la fonction summary().\n\nx &lt;- rnorm(n = 1e3, mean = 10, sd = 2)\nsummary(x)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  3.720   8.573   9.934   9.913  11.260  16.073 \n\n\n\n\n5.1.2 Variable qualitative\nDans le cas des variables qualitatives, on ne peut pas réaliser de statistiques. On décrira la variable par les opération listées dans le tableau ci-dessous :\n\n\n\n\n\n\n\nOpération\nFonction R\n\n\n\n\nLister les modalités\nunique(x)\n\n\nNombre de modalités\nlength(unique(x))\n\n\nNombre de valeurs par modalité\ntable(x) ((table(x) / length(x)) * 100)\n\n\nNombre d’observations\nlength(x)",
    "crumbs": [
      "Traitements et analyse de données",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Statistiques</span>"
    ]
  },
  {
    "objectID": "ressources/viz/graph.html",
    "href": "ressources/viz/graph.html",
    "title": "7  Visualisation de données",
    "section": "",
    "text": "7.1 Les graphs de base sous R\nUn des points forts de R réside dans sa capacité à produire simplement des graphiques léchés. Pour cela, on emploie l’hégémonique package ggplot2. Il est basé sur The Grammar of Graphics (2005), ouvrage de référence sur la data-visualisation.\nR vient avec des fonctions de base pour représenter des données. Ces fonctions sont pratiques dans la mesure où on peut créer un graphique en très peu de ligne de code.\nCode\n# On supprime les valeurs manquantes pour éviter les erreurs\npenguins &lt;- drop_na(penguins)\n\n# Définir la grille 2x2 pour afficher plusieurs graphiques\npar(mfrow = c(2, 2))\n\n# Graphe en ligne : masse moyenne par année\nmean_mass &lt;- summarise(penguins, mean_mass = mean(body_mass_g), .by = year)\nplot(mean_mass$year, mean_mass$mean_mass, type = \"l\", col = \"blue\",\n     xlab = \"Année\", ylab = \"Masse moyenne (g)\",\n     main = \"Masse moyenne des manchots par année\")\n\n# Graphe en barres : nombre d'individus par espèce\nbarplot(table(penguins$species), col = c(\"skyblue\", \"orange\", \"lightgreen\"),\n        main = \"Nombre d'individus par espèce\",\n        ylab = \"Effectif\")\n\n# Histogramme : distribution de la longueur du bec\nhist(penguins$bill_length_mm, col = \"lightblue\", border = \"white\",\n     main = \"Distribution de la longueur du bec\",\n     xlab = \"Longueur du bec (mm)\")\n\n# Boxplot : masse corporelle selon l'espèce\nboxplot(body_mass_g ~ species, data = penguins,\n        col = c(\"skyblue\", \"orange\", \"lightgreen\"),\n        main = \"Masse corporelle par espèce\",\n        ylab = \"Masse (g)\")\nLes graphiques produits sont difficillement personnalisables et souvent peu au goût des utilisateurs. Dès que l’on souhaite produire des graphiques léchés, on se tourne vers ggplot2.",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visualisation de données</span>"
    ]
  },
  {
    "objectID": "ressources/viz/graph.html#sec-ggplot",
    "href": "ressources/viz/graph.html#sec-ggplot",
    "title": "7  Visualisation de données",
    "section": "7.2 Graphiques avec ggplot2",
    "text": "7.2 Graphiques avec ggplot2\nBeaucoup d’encre a coulé sur le sujet. Je ne vais pas réinventer l’eau chaude. Vous trouverez tous ce qu’il vous faut dans le chapitre Graphiques avec ggplot2 de Joseph larmarange.\n\n7.2.1 Les geoms de bases\n\n\n\n\n\n\n\nFonction ggplot2\nDescription\n\n\n\n\ngeom_point()\nNuage de points (relation entre deux variables)\n\n\ngeom_line()\nCourbe / ligne (évolution, série temporelle)\n\n\ngeom_bar()\nGraphique en bâtons (comptage automatique)\n\n\ngeom_histogram()\nHistogramme (distribution d’une variable)\n\n\ngeom_density()\nCourbe de densité (distribution lissée)\n\n\ngeom_boxplot()\nBoîte à moustaches (résumé statistique)\n\n\ngeom_tile()\nCarte de chaleur (heatmap)\n\n\ngeom_text()\nAjout de texte sur le graphique\n\n\ngeom_hline()\nLigne horizontale\n\n\ngeom_vline()\nLigne verticale\n\n\n\n\n7.2.1.1 Les lignes\nPour réaliser des nuages de points, on utilise geom_point().\n\nto_plot_tot &lt;- penguins |&gt;\n    dplyr::count(year)\nto_plot_species &lt;- penguins |&gt;\n    dplyr::count(year, species)\n\npal &lt;- MetBrewer::met.brewer(\"Isfahan2\") # color-blind friendly\n\n# Graphique en lignes\np1 &lt;- ggplot(to_plot_tot, aes(x = year, y = n)) +\n  geom_line() + theme_minimal()\np2 &lt;- ggplot(to_plot_species, aes(x = year, y = n, color = species)) +\n    geom_line(linewidth = 1) +\n    scale_color_manual(values = pal) +\n    theme_minimal() +\n    theme(legend.position = \"bottom\")\nwrap_plots(list(p1, p2))\n\n\n\n\n\n\n\n\n\n\n7.2.1.2 Les nuages de points\nPour réaliser des nuages de points, on utilise geom_point().\n\n# Nuage de points\np1 &lt;- ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +\n  geom_point()\np2 &lt;- ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +\n  geom_point() +\n    scale_color_manual(values = pal)\np3 &lt;- ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, fill = species)) +\n  geom_point(shape = 21, color = \"white\", alpha = 0.5, size = 4)  +\n    scale_fill_manual(values = pal)\np4 &lt;- ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, size = body_mass_g)) +\n  geom_point(color = pal[3], alpha = 0.3) +\n  scale_size(range = c(0, 8))\n\n# All graph in a single one\nplts &lt;- list(p1, p2, p3, p4)\nplts &lt;- map(plts, ~.x + theme_minimal() + theme(legend.position = \"bottom\"))\nwrap_plots(plts)\n\n\n\n\n\n\n\n\n\n\n7.2.1.3 Les graphs en baton\n\nto_plot &lt;- drop_na(penguins)\n\np1 &lt;- ggplot(to_plot, aes(x = species)) +\n  geom_bar()\np2 &lt;- ggplot(to_plot, aes(x = species, fill = island)) +\n  geom_bar() +\n  labs(title = \"position = \\\"stack\\\"\") +\n  scale_fill_manual(values = pal)\np3 &lt;- ggplot(to_plot, aes(x = species, fill = island)) +\n  geom_bar(position = \"dodge\") +\n  labs(title = \"position = \\\"dodge\\\"\") +\n  scale_fill_manual(values = pal)\np4 &lt;- ggplot(to_plot, aes(x = species, fill = island)) +\n  geom_bar(position = \"fill\") +\n  labs(title = \"position = \\\"fill\\\"\") +\n  scale_fill_manual(values = pal)\n\n# All graph in a single one\nplts &lt;- list(p1, p2, p3, p4)\nplts &lt;- map(plts, ~.x + theme_minimal() + theme(legend.position = \"bottom\"))\nwrap_plots(plts)\n\n\n\n\n\n\n\n\n\n\n7.2.1.4 Les graphiques statistiques\nPour rappel, les graphiques statistiques servent à comprendre la distribution des variables.\nBoîte à moustache (et associés) :\n\np1 &lt;- ggplot(penguins, aes(y = body_mass_g)) +\n  geom_boxplot()\np2 &lt;- ggplot(penguins, aes(x = species, y = bill_length_mm)) +\n  geom_boxplot()\np3 &lt;- ggplot(penguins, aes(x = species, y = bill_length_mm, fill = species)) +\n  geom_boxplot() +\n  scale_fill_manual(values = pal)\np4 &lt;- ggplot(penguins, aes(x = species, y = bill_length_mm, fill = species)) +\n  geom_violin() +\n  geom_boxplot(width = 0.1, fill = \"white\") +\n  scale_fill_manual(values = pal)\n\nplts &lt;- list(p1, p2, p3, p4)\nplts &lt;- map(plts, ~.x + theme_minimal() + theme(legend.position = \"bottom\"))\nwrap_plots(plts)\n\n\n\n\n\n\n\n\nHistogrames :\n\np1 &lt;- ggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram()\np2 &lt;- ggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(bins = 80)\np3 &lt;- ggplot(penguins, aes(x = body_mass_g, fill = species)) +\n  geom_histogram(color = \"white\") +\n  scale_fill_manual(values = pal)\np4 &lt;- ggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(aes(y = ..density..), fill = \"white\", color = \"black\") +\n  geom_density(fill = pal[3], alpha = 0.2)\n\nplts &lt;- list(p1, p2, p3, p4)\nplts &lt;- map(plts, ~.x + theme_minimal() + theme(legend.position = \"bottom\"))\nwrap_plots(plts)\n\n\n\n\n\n\n\n\nCourbe de fréquence cumulée (Empirical Cumulative Distribution Function) :\n\np1 &lt;- ggplot(penguins, aes(x = body_mass_g)) +\n  stat_ecdf(geom = \"step\")\np2 &lt;- ggplot(penguins, aes(x = body_mass_g, color = species)) +\n  stat_ecdf(geom = \"step\") +\n  scale_color_manual(values = pal)\n\nplts &lt;- list(p1, p2)\nplts &lt;- map(plts, ~.x + theme_minimal() + theme(legend.position = \"bottom\"))\nwrap_plots(plts)\n\n\n\n\n\n\n\n\n\n\n\n7.2.2 Faire des graphs par groupe\nAvec ggplot2, il est possible de générer des graphs par groupes. Par exemple, on peut vouloir comparer la longueur et la profondeur du bec des pingouins par espèce dans des graphs séparés. Plutôt que d’écrire manuellement trois graphs ou d’écrire une boucle, on peut utiliser la fonction facet_wraps().\n\nggplot(penguins, aes(bill_length_mm, bill_depth_mm)) +\n    geom_point() +\n    facet_wrap(vars(species))\n\n\n\n\n\n\n\n\nOn peut aussi garder l’ensemble du nuage sur chaque plot pour faciliter la comparaison :\n\nggplot(penguins, aes(bill_length_mm, bill_depth_mm)) +\n    geom_point(data = transform(penguins, species = NULL), colour = \"grey85\") +\n    geom_point() +\n    facet_wrap(vars(species))\n\n\n\n\n\n\n\n\n\n\n7.2.3 Apparence\nPour modifier l’apparence du graphique, on utilise la fonction theme(). Vous pouvez tout modifier, le texte, la grille, les axes, etc. (cf. Figure 7.1).\n\n\n\n\n\n\nFigure 7.1: Fiche de référence du thème ggplot2 par Isabella Benabaye (source)\n\n\n\n\n7.2.3.1 Les thèmes par défaut\nIl existe de nombreux thèmes par défaut que vous pouvez essayez. Par exemple :\n\np &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  labs(\n    title = \"Fuel Efficiency vs Weight\",\n    x = \"Weight (1000 lbs)\",\n    y = \"Miles per Gallon\",\n    caption = \"source : mtcars (dplyr), 2025. Réal. : Antoine Le Doeuff, 2025\"\n  )\n\np1 &lt;- p + labs(caption = \"\") + theme_minimal()\np2 &lt;- p + theme_classic()\npatchwork::wrap_plots(list(p1, p2))\n\n\n\n\n\n\n\n\nDes packages proposent des packages supplémentaires prêt à l’emploie. Je vous conseil ces deux packages1 : bbplot, hrbrthemes.\n1 Vous trouverez une liste plus exhaustive ici.\n\n\nExemple de graphs réalisés avec bbplot. (bbplot, 2025)\n\n\n\n\n7.2.3.2 Les couleurs\nPour modifier les couleurs des couches, on utilise les fonctions scale_color_*() ou scale_fill_*() en fonction de l’esthétique que vous aurez spécifié dans votre votre couche.\n\n\n\n\n\n\nPensez aux daltonien⋅nes\n\n\n\nUtilisez des palettes discernables par les daltonien⋅nes (color-blind friendly).\nVous pouvez avoir un aperçu de comment votre plot sera perçu pour un⋅e daltonien⋅ne avec la fonction colorblindr::cvd_grid().\n\np_bl &lt;- ggplot(mtcars, aes(x = wt, y = mpg, color = as.factor(carb))) +\n  geom_point() +\n  theme_minimal()\n\ncolorblindr::cvd_grid(p_bl)\n\n\n\n\n\n\n\n\n\n\nPersonnellement, j’aime bien les packages suivants :\n\nMetBrewer: Inspiré des œuvres du MET\nMexBrewer: Inspiré par les peintres et muralistes mexicains.\nMoMA: Inspiré des œuvres exposées au MoMA.\nPNWColors: Inspiré des couleurs du Pacific Nord-Ouest.\nwesanderson: Inspiré des couleurs présentes dans les films de Wes Anderson.\nNatParksPalettes: Inspiré de photos de parcs naturels.\nscico: Très bien pour les palettes de couleurs continues.\n\n\n\n7.2.3.3 Textes\nPour modifier la police de caractère, on peut par exemple employer la fonction font_add_google() du package sysfont. Cela vous permet d’importer une famille typographique depuis google font.\n\n# Charger la font\nsysfonts::font_add_google(name = \"Roboto\", family = \"roboto\")\n\np +\n  theme(\n    plot.title = element_text(family = \"roboto\", size = 16, face = \"bold\"),\n    axis.title.x = element_text(family = \"roboto\", size = 12),\n    axis.title.y = element_text(family = \"roboto\", size = 12),\n    plot.caption = element_text(family = \"roboto\", size = 8)\n  )\n\n\n\n\n\n\n\n\nPour plus de controle sur le rendu texte, vous pouvez utiliser le package ggtext. Celui-ci vous permet notamment d’écrire vos labels en markdown.\n\nlibrary(ggtext)\n\np +\n  labs(\n    title = \"Efficacité énergétique vs Poids\",\n    x = \"*Poids* (1000 lbs)\",\n    y = \"*Miles per Gallon*\",\n    caption = \"**Source :** mtcars (dplyr), 2025&lt;br&gt;**Réalisation :** Antoine Le Doeuff, 2025\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_markdown(family = \"roboto\", size = 16, face = \"bold\"),\n    axis.title.x = element_markdown(family = \"roboto\", size = 12),\n    axis.title.y = element_markdown(family = \"roboto\", size = 12),\n    plot.caption = element_markdown(family = \"roboto\", size = 8, lineheight = 1.5)\n  )\n\n\n\n\n\n\n\n\n\n\n7.2.3.4 Créer son propre thème\nQuant on rédige un document, on s’appuie sur une identité visuelle basée en partie sur une charte graphique. En un mot : il faut se tenir à des règles graphiques valables pour l’ensemble de figures. ggplot2 permet de mettre en œuvre cette règle simplement par la création d’un thème que l’on pourra appliquer à tout objet ggplot2 (cartes comprises).\nPrenons un exemple, construisons un thème basé sur le thème ggplot2 par défaut theme_minimal() :\n\nsysfonts::font_add_google(name = \"Roboto\", family = \"roboto\")\n\nmy_theme &lt;- function(base_size = 11, base_family = \"roboto\", theme_color = \"#00976f\") {\n  ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +\n    ggplot2::theme(\n      # Titres\n      plot.title = ggtext::element_markdown(\n        family = \"roboto\", size = base_size + 5, face = \"bold\", color = theme_color\n      ),\n      axis.title.x = ggtext::element_markdown(family = \"roboto\", size = base_size, face = \"italic\"),\n      axis.title.y = ggtext::element_markdown(family = \"roboto\", size = base_size, face = \"italic\"),\n      plot.caption = ggtext::element_markdown(family = \"roboto\", size = base_size - 3, lineheight = 1.5),\n\n      # Légende\n      legend.position = \"right\",\n      legend.title = ggplot2::element_text(face = \"bold\"),\n      legend.background = ggplot2::element_blank(),\n      legend.key = ggplot2::element_blank(),\n\n      # Marges\n      plot.margin = ggplot2::margin(5, 5, 5, 5)\n    )\n}\n\n\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  labs(\n    title = \"Efficacité énergétique vs Poids\",\n    x = \"Weight (1000 lbs)\",\n    y = \"Miles per Gallon\",\n    caption = \"**Données :** mtcars (dplyr), 2025.&lt;br&gt;**Réalisation :** Antoine Le Doeuff, 2025\"\n  ) +\n  my_theme()\n\n\n\n\n\n\n\n\nOn peut faire d’un thème le thème par défaut pour la session R courante.\n\ntheme_set(my_theme())\n\nggplot(mtcars, aes(x = as.factor(cyl), y = mpg)) +\n  geom_boxplot() +\n  labs(\n    title = \"Efficacité énergétique vs Nombre de cylindres\",\n    x = \"Nombre de cylindres\",\n    y = \"Miles per Gallon\",\n    caption = \"**Données :** mtcars (dplyr), 2025.&lt;br&gt;**Réalisation :** Antoine Le Doeuff, 2025\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n7.2.4 Combiner des graphs\nIl existe de nombreux packages pour combiner des graphs ggplot sous R, voici les plus utilisés :\n\npacthwork : Le plus utilisé aujourd’hui, il est très intuitif.\ncowplot : Très utilisé historiquemeny\ngridExtra : Ancien mais encore courant\n\nJe vous conseil d’utiliser patchwork. Pour combiner deux graphs horizontalement, on utilise le + :\n\nlibrary(patchwork)\n\np1 &lt;- ggplot(penguins) + geom_point(aes(bill_depth_mm, bill_length_mm))\np2 &lt;- ggplot(penguins) + geom_boxplot(aes(species, body_mass_g))\n\np1 + p2\n\n\n\n\n\n\n\n# Ce qui revient au même que wrap_plots(list(p1, p2), nrow = 1, ncol = 2)\n\nPour combiner deux graphs verticalement, le / :\n\np3 &lt;- ggplot(penguins) + stat_ecdf(aes(body_mass_g), geom = \"step\")\np4 &lt;- ggplot(penguins) + geom_bar(aes(species))\n\np3 / p4\n\n\n\n\n\n\n\n# Ce qui revient au même que wrap_plots(list(p1, p2), nrow = 2, ncol = 1)\n\nOn peut combiner les opérateurs pour obtenir un rendu complexe :\n\np_all &lt;- (p1 | p2 | p3) / p4\n\nVous pouvez bien sûr ajouter des annotations aux graphs.\n\np_all +\n  plot_annotation(\n    title = \"Graphiques combinés\",\n    caption = \"Données : palmerpenguins, 2025. Réalisation : Antoine Le Doeuff, 2025\",\n    # Ajouter des tags\n    tag_levels = 'A',\n  )",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Visualisation de données</span>"
    ]
  },
  {
    "objectID": "ressources/viz/map.html",
    "href": "ressources/viz/map.html",
    "title": "8  Cartographie",
    "section": "",
    "text": "8.1 Cartographie avec ggplot2\nIl existe de nombreux packages pour faire de la cartographie sous R. Chacun a sa propre façon de fonctionner.\nLes packages généraux les plus utilisés sont :\nPour crééer des cartes spécifiques :\nOn va se concentrer sur ggplot2 + sf car la syntaxe est la même que pour les graphiques avec ggplot2.\ngeom_sf() est une fonction du package ggplot2 qui permet de représenter des objets spatiaux au format sf (simple features). Elle offre une intégration fluide entre les données géographiques et le système de visualisation de ggplot2, sans avoir besoin d’utiliser des outils externes.\nn peut facilement afficher une carte simple à partir d’un jeu de données géographiques intégré comme rnaturalearth :\n# Charger les données du monde\nworld &lt;- ne_countries(scale = \"medium\", returnclass = \"sf\")\n\n# Carte du monde\nggplot(data = world) +\n  geom_sf(fill = \"lightblue\", color = \"white\") +\n  labs(title = \"Carte du monde avec geom_sf()\") +\n  theme_minimal()\nIci, chaque polygone représente un pays. L’esthétique (fill, color) fonctionne comme pour les autres géométries de ggplot2.",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cartographie</span>"
    ]
  },
  {
    "objectID": "ressources/viz/map.html#sec-carto-ggplot",
    "href": "ressources/viz/map.html#sec-carto-ggplot",
    "title": "8  Cartographie",
    "section": "",
    "text": "8.1.1 Carto thématique\nOn charge les librairies et on télécharge les données.\n\n\nCode\nlibrary(happign)\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(ggspatial)\n\ncom_fin &lt;- get_wfs(\n    x = NULL,\n    layer = \"LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune\",\n    ecql_filter = \"code_insee LIKE '29%'\"\n)\nbrest &lt;- st_buffer(filter(com_fin, nom_officiel == \"Brest\"), 30e3)\nocsol &lt;- get_wfs(brest, layer = \"BDCARTO_V5:occupation_du_sol\", spatial_filter = \"bbox\")\n\n\n\n8.1.1.1 Choroplète catégorielle\n\n# Définition des couleurs\npal &lt;- c(\n  \"Prairie\"            = \"#bece4d\",\n  \"Eau libre\"          = \"#4fbddc\",\n  \"Sable, gravier\"     = \"#cccccc\",\n  \"Bâti\"               = \"#fc4278\",\n  \"Zone d'activités\"   = \"#ff9191\",\n  \"Marais, tourbière\"  = \"#80be00\",\n  \"Broussailles\"       = \"#80ff00\",\n  \"Carrière, décharge\" = \"#ffff99\",\n  \"Forêt\"              = \"#00a600\"\n)\n\nggplot() +\n  # Définition de la couche\n  geom_sf(data = ocsol, aes(fill = nature), color = NA) +\n  geom_sf(data = com_fin, color = \"white\", fill = NA, linewidth = .5) +\n  # Zoom sur Brest\n  coord_sf(xlim = c(-4.61669,-4.3900), ylim = c(48.36100, 48.46172), crs = 4326) +\n  labs(\n    title = \"Occupation du sol de Brest et ses alentours en 2018\",\n    fill = \"Nature\",\n    caption = \"Data: BD Carto V5 (IGN), 2025. Réalisation: Antoine Le Doeuff, 2025\"\n  ) +\n  scale_fill_manual(values = pal) +\n  # Échelle\n  annotation_scale(location = \"br\") +\n  # Nord\n  annotation_north_arrow(\n      location = \"tr\", which_north = \"true\",\n      style = north_arrow_fancy_orienteering\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\",\n    axis.text = element_blank(),\n    plot.title = element_text(size = 16, face = \"bold\"),\n  )\n\n\n\n\n\n\n\n\nsf ne permet pas de créer des échelles et des orientations directement, il faut passer par ggspatial (annotation_north_arrow(), annotation_scale()).\n\n\n8.1.1.2 Choroplète continue\n\ncom_fin &lt;- get_wfs(\n  x = NULL,\n  layer = \"LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune\",\n  ecql_filter = \"code_insee LIKE '29%'\"\n)\n\nFeatures downloaded : 277\n\ncom_fin &lt;- mutate(com_fin,\n  area = as.numeric(st_area(geometry)),\n  dens = population / area * 1e6L\n)\n\n\nggplot() +\n  # Définition de la couche\n  geom_sf(data = com_fin, aes(fill = dens)) +\n  # Zoom sur Brest\n  labs(\n    title = \"Densité de population communale en Finistère\",\n    subtitle = \"Année : 2025\",\n    fill = \"Densité (hab/km²)\",\n    caption = \"Data: Admin Express (IGN), 2025. Réalisation: Antoine Le Doeuff, 2025\"\n  ) +\n  scale_fill_continuous(palette = \"Reds\") +\n  # Échelle\n  annotation_scale(location = \"bl\") +\n  # Nord\n  annotation_north_arrow(\n      location = \"tl\", which_north = \"true\",\n      style = north_arrow_fancy_orienteering\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = c(.1, .3),\n    plot.title = element_text(size = 16, face = \"bold\"),\n    plot.subtitle = element_text(size = 14),\n  )\n\n\n\n\n\n\n\n\n\n\n8.1.1.3 Choroplète\nAvec geom_sf(), on ne peut pas générer de discrétisation automatiquement. Il faut d’abord créer les classes avec la fonction classInt::classIntervals().\n\nlibrary(patchwork)\n\n# Create differents discretisation\ndisc &lt;- c(\"equal\", \"pretty\", \"quantile\", \"jenks\")\nd &lt;- \"pretty\"\nmaps &lt;- purrr::map(disc, \\(d) {\n  com_fin[[paste0(\"disc_\", d)]] &lt;- cut(\n      com_fin$dens,\n      breaks = classInt::classIntervals(com_fin$dens, n = 5, style = d, dataPrecision=0)$brks,\n      include.lowest = TRUE, dig.lab = 4\n  )\n\n  ggplot(com_fin) +\n    # Définition de la couche\n    geom_sf(aes(fill = .data[[paste0(\"disc_\", d)]])) +\n    labs(\n        title = paste(\"Discrétisation :\", d),\n        fill = \"Densité (hab/km²)\"\n    ) +\n    scale_fill_discrete(palette = \"Reds\") +\n    annotation_scale(location = \"bl\") +\n    annotation_north_arrow(\n        location = \"tl\", which_north = \"true\",\n        style = north_arrow_fancy_orienteering\n    ) +\n    theme_minimal() +\n    theme(\n        legend.position = \"right\",\n        axis.text = element_blank()\n    )\n})\nwrap_plots(maps) +\n  plot_annotation(\n    title = \"Densité de population en Finistère\",\n    subtitle = \"Année : 2025\",\n    caption = \"Data: Admin Express (IGN), 2025. Réalisation: Antoine Le Doeuff, 2025\",\n    theme = theme(plot.title = element_text(size = 18, face = \"bold\"))\n  )\n\n\n\n\n\n\n\n\n\n\n8.1.1.4 Cercles proportionnels\nPour faire des cartes en symbole proportionnels, il faut d’abord convertir les entités spatiales en points. On utilise ensuite geom_sf() avec l’argument size dans l’esthétique de la couche.\n\n# Calcul du centroïde des communes\ncom_centro &lt;- st_centroid(com_fin)\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n# Discrétisation quantile\nbrks &lt;- classInt::classIntervals(com_centro$population, n = 5, style = \"quantile\", dataPrecision=0)$brks\n\nggplot(com_centro) +\n  # Définition de la couche\n  geom_sf(data = com_fin) +\n  geom_sf(aes(size = population), color = \"white\", fill = \"steelblue\", shape = 21) +\n  # Zoom sur Brest\n  labs(\n      title = \"Population des communes finistériennes\",\n      subtitle = \"Année 2025 ; Discrétisation : quantile\",\n      size = \"Population\",\n      caption = \"Données : Admin Express (IGN), 2025. Réalisation : Antoine Le Doeuff, 2025\"\n  ) +\n  scale_size_area(\n    max_size = 11,\n    breaks = brks,\n    labels = brks\n  ) +\n  # Échelle\n  annotation_scale(location = \"bl\") +\n  # Nord\n  annotation_north_arrow(\n      location = \"tl\", which_north = \"true\",\n      style = north_arrow_fancy_orienteering\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = c(.1, .3),\n    plot.title = element_text(size = 18, face = \"bold\"),\n    plot.subtitle = element_text(size = 14)\n  )\n\n\n\n\n\n\n\n\n\n\n\n8.1.2 Les petits plus\n\n8.1.2.1 Simplifier une géométrie\nUne des règles en cartographie est d’utiliser un fond de carte dont la géométrie est adaptée à l’échelle utilisée. Si votre géométrie est trop détaillée, votre carte sera “surchargée”. Pour simlifier une géométrie, on peut utiliser sf::st_simplify(). Cependant, cette derières ne permet pas une simplification cohérente des géométries de type multipolygon. Aussi, pour ce type de géométrie, on utilisera la fonction ms_simplify() du package rmapshaper1.\n1 mapshaper utilise la simplification de Visvalingam. Il existe une application en ligne qui permet de réaliser cette simplication de manière intéractives.\nlibrary(purrr)\n\n# Vecteur de valeur de simplification\nkeeps &lt;- c(0.01, 0.001, 0.0001)\nfin_simps &lt;- map(keeps, ~rmapshaper::ms_simplify(com_fin, keep = .x))\nfins &lt;- c(list(com_fin), fin_simps) |&gt; set_names(c(\"0\", keeps))\n\nmaps &lt;- purrr::imap(fins, \\(f, n_simp) {\n    ggplot(f) +\n      geom_sf() +\n      labs(title = paste(\"simp =\", n_simp)) +\n      theme_minimal()\n})\nwrap_plots(maps) +\n    plot_annotation(\n      title = \"Simplication de la géométrie des communes finistériennes\",\n      caption = \"Données : Admin Express (IGN), 2025. Réalisation : Antoine Le Doeuff, 2025\",\n      theme = theme(plot.title = element_text(size = 15, face = \"bold\"))\n    )\n\n\n\n\n\n\n\n\n\n\n8.1.2.2 Fond de cartes open source\nTout sous QGIS, vous pouvez charger des fonds de cartes open-source. Pour cela, vous pouvez par exemple, utiliser le package basemapR.\n\nlibrary(basemapR)\n\ntsport &lt;- get_wfs(\n  x = filter(com_fin, nom_officiel == \"Pont-l'Abbé\"),\n  layer = \"BDTOPO_V3:terrain_de_sport\",\n  spatial_filter = \"within\"\n)\n\nFeatures downloaded : 16\n\nggplot() +\n  basemapR::base_map(st_bbox(tsport), increase_zoom = 2, basemap = \"positron\") +\n  geom_sf(data = tsport, fill = \"red\") +\n  labs(\n    title = \"Terrain de sport à Pont-l'Abbé (29) en 2025\",\n    caption = \"Données : BTOPO (IGN), 2025 ; CartoDB & OpenStreetMap, 2025. Réalisation: Antoine Le Doeuff\"\n  ) +\n  annotation_scale(location = \"bl\") +\n  annotation_north_arrow(\n      location = \"tl\", which_north = \"true\",\n      style = north_arrow_fancy_orienteering\n  ) +\n  theme_minimal() +\n  theme(axis.text = element_blank())\n\n\n\n\n\n\n\n\nMéfiez-vous de ces types de fond de carte. Ils peuvent considérablement alourdir vos cartes avec des informations superflues.",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Cartographie</span>"
    ]
  },
  {
    "objectID": "ressources/where_data/where_data.html",
    "href": "ressources/where_data/where_data.html",
    "title": "9  Où trouver des données",
    "section": "",
    "text": "9.1 Sources de données par thématique\nIl existe des listes de données en ligne. Elles sont plutôt exhaustives pour les données mondiales, c’est moins vrai pour les données à l’échelle des pays :",
    "crumbs": [
      "Sources de données",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Où trouver des données</span>"
    ]
  },
  {
    "objectID": "ressources/where_data/where_data.html#sources-de-données-par-thématique",
    "href": "ressources/where_data/where_data.html#sources-de-données-par-thématique",
    "title": "9  Où trouver des données",
    "section": "",
    "text": "Démographie et population\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nIPUMS (International / USA)\nMonde\n\n\nWorld Bank Open Data\nMonde\n\n\nUNData\nMonde\n\n\nEurostat\nEurope\n\n\nINSEE\nFrance\n\n\nINED\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nTransports\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nGTFS (opérateurs)\nMonde\n\n\nWorld Bank Open Data\nMonde\n\n\nEurostat\nEurope\n\n\nSNCF Open Data\nFrance\n\n\n\nCertaines métropololes proposent des données de transports en commun en temps réels (par-ex. Rennes).\n\n\n\n\n\n\n\n\n\nAgriculture et alimentation\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nFAO (FAOSTAT)\nMonde\n\n\nWorld Bank Open Data\nMonde\n\n\nEurostat\nEurope\n\n\nAgreste\nFrance\n\n\nRPG (Registre Parcellaire Graphique) (IGN)\nFrance\n\n\nINRAE Open Data\nSurtout France\n\n\n\n\n\n\n\n\n\n\n\n\nSanté\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nWHO\nMonde\n\n\nWorld Bank Open Data\nMonde\n\n\nIPUMS\nMonde\n\n\nDREES\nFrance\n\n\nSanté publique France\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nUrbanisme, habitat et aménagement\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nUN-Habitat\nMonde\n\n\nWorld Bank Open Data\nMonde\n\n\nEurostat\nEurope\n\n\nINSEE\nFrance\n\n\nCEREMA (aménagement)\nFrance\n\n\nDVF (Demande de Valeurs Foncières)\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nÉconomie, emploi et inégalités\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nWorld Bank Open Data\nMonde\n\n\nIMF Data\nMonde\n\n\nOECD Data\nMonde\n\n\nEurostat\nEurope\n\n\nINSEE\nFrance\n\n\nURSSAF Open Data\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nÉducation\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nUNESCO Institute for Statistics\nMonde\n\n\nWorld Bank Open Data\nMonde\n\n\nOECD Data\nMonde\n\n\nDEPP (MEN)\nFrance\n\n\nINSEE\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nMigrations et mobilités humaines\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nUNData\nMonde\n\n\nWorld Bank Open Data\nMonde\n\n\nOECD Data\nMonde\n\n\nEurostat\nEurope\n\n\nINSEE\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nPolitique et conflits\n\n\n\n\n\n\n\n\nThème\nSource\nEmprise\n\n\n\n\nConflits\nACLED\nMonde\n\n\nPolitique\nV-Dem (démocratie)\nMonde\n\n\nPolitique\ndata.gouv.fr – élections\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nOccupation/utilisation du sol\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nCopernicus Land Monitoring Service\nMonde\n\n\nCorine Land Cover\nEurope\n\n\nTheia Land\nFrance métropolitaine\n\n\nOCS GE (IGN)\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nÉlévation\n\n\n\n\n\n\n\n\nSource\nRésolution\nEmprise\n\n\n\n\nASTER\n30 m\nMonde\n\n\nSRTM\n\\(\\approx\\) 90 m\nMonde\n\n\nBD ALTI (IGN)\n25 m\nFrance\n\n\nRGE ALTI (IGN)\n1 m\nFrance\n\n\nLitto 3D (IGN/SHOM)\n20 à 50 cm\nFrance (littoral)\n\n\n\n\n\n\n\n\n\n\n\n\nClimat et météo\n\n\n\n\n\n\n\n\nSource\nType\nEmprise\n\n\n\n\nWorldClim\nObservation / Modèle\nMonde\n\n\nERA5\nModèle\nMonde\n\n\nMétéo-France\nObservation / Modèle\nFrance\n\n\nSAFRAN\nModèle\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nHydrologie\n\n\n\n\n\n\n\n\nSource\nEmprise\n\n\n\n\nHydro SHEDS\nMonde\n\n\nHydro Portail\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nNiveau d’eau et état de mer\n\n\n\n\n\n\n\n\nThème\nSource\nType\nEmprise\n\n\n\n\nÉtats de mer\nCopernicus Marine Service\nObservation\nMonde\n\n\nÉtats de mer\nCandhis (CEREMA)\nObservation\nFrance\n\n\nÉtats de mer\nERA5\nModèle\nMonde\n\n\nÉtats de mer\nRessource Code\nModèle\nFaçade Atlantique Européenne\n\n\nNiveau d’eau\nPSML\nObservation\nMonde\n\n\nNiveau d’eau\nFES2022\nModèle\nMonde\n\n\nNiveau d’eau\nSHOM\nObservation / Modèle\nFrance\n\n\n\n\n\n\n\n\n\n\n\n\nÉcologie, biologie\n\n\n\n\n\n\n\n\nThème\nSource\nEmprise\n\n\n\n\nBiodiversité\nGlobal Biodiversity Information Facility\nMonde\n\n\nBiodiversité\nOcean Biodiversity Information System\nMonde\n\n\nBiodiversité\nUICN red list\nMonde\n\n\nSol\nISRIC\nMonde\n\n\nSol\nGis Sol\nFrance",
    "crumbs": [
      "Sources de données",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Où trouver des données</span>"
    ]
  },
  {
    "objectID": "ressources/where_data/where_data.html#fond-de-cartes",
    "href": "ressources/where_data/where_data.html#fond-de-cartes",
    "title": "9  Où trouver des données",
    "section": "9.2 Fond de cartes",
    "text": "9.2 Fond de cartes\n\n9.2.1 France\nPour obtenir des fonds de cartes du territoire français, on se tournera vers l’IGN. Tout ce que vous voyez sur une carte topographique IGN, vous pouvez le récupérer. L’IGN organise ses données par base, vous trouverez ci-dessous une description des bases les plus courrament utilisées :\n\n\n\nBase\ntype\nDescription\n\n\n\n\nAdmin Express\nVectoriel\nBase de données du découpage administratif français\n\n\nBDCarto\nVectoriel\nBase de données moyenne échelle\n\n\nBDTopo\nVectoriel\nBase de données détaillées\n\n\nContours…IRIS\nVectoriel\nLe contour des IRIS\n\n\nBDALTI\nRaster\nModèle Numérique de Terrain (MNT). Résolution 25 m\n\n\nBDOrtho\nRaster\nBase d’orthophotos de l’IGN. Résolution 20 cm\n\n\n\nUne liste des bases plus détaillée est disponible sur le site de l’IGN. Les métadonnées sont disponibles sur la page web dédiée.\nPou récupérer ces données, vous pouvez vous rendre sur le site de l’IGN et les télécharger. Il est également possible de les télécharger directement sur R avec le package happign. En utilisant ce package vous vous assurez de ne télécharger que les données dont vous avez besoin1.\n1 En effet, sur le site de l’IGN vous ne pouvez que télécharger les bases par départements sans possibilité de choisir les données que vous souhaitez en particulier ; pas très écolo cette affaire.Mettons que l’on souhaite récupérer les bâtiments de Guissény (29) ainsi que l’emprise administrative de la commune. Si l’on a aucune idée d’où l’on peut trouver les bâtiments, on peut chercher dans les métadonnées des couches vectorielles.\n\nlibrary(happign)\n\n# Récupération des métadonnées\nmeta &lt;- get_layers_metadata(data_type = \"wfs\")\n\n# Récupération du nom des couches\nname &lt;- meta$Name\n\n# On cherche les couches qui contiennent la chaîne de caractère \"bati\"\ncom_name &lt;- name[grep(x = name, \"commune\")]\nhead(com_name)\n\n[1] \"LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:chef_lieu_de_commune\"                     \n[2] \"LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:chef_lieu_de_commune_associee_ou_deleguee\"\n[3] \"LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune\"                                  \n[4] \"LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune_associee_ou_deleguee\"             \n[5] \"ADMINEXPRESS-COG.2017:commune\"                                                   \n[6] \"ADMINEXPRESS-COG.2018:commune\"                                                   \n\nbati &lt;- name[grep(x = name, \"bati\")]\nhead(bati)\n\n[1] \"BAN-PLUS:lien_adresse_bati\"                                 \n[2] \"BAN-PLUS:lien_bati_parcelle\"                                \n[3] \"BDCARTO_ETAT-MAJOR.NIVEAU4:c_1_2_ocs_ancien_sans_bati\"      \n[4] \"BDCARTO_ETAT-MAJOR.NIVEAU4:c_2_1_batiment\"                  \n[5] \"BDCARTO_ETAT-MAJOR.NIVEAU4:c_2_2_batiment_hors_zone_urbaine\"\n[6] \"BDCARTO_ETAT-MAJOR.NIVEAU3:c_1_2_ocs_ancien_sans_bati\"      \n\n\nOn obtient toute les données disponibles. Nous utiliserons les données de la BDTOPO BDTOPO_V3:batiment. L’étape suivant consiste à filtrer la couche pour ne retenir que les informations qui nous intéresse. On peut filtrer par attributs ou par opération spatiale. Le filtre sera réalisé sur les serveurs de l’IGN et vous récupérez le résultat.\nPour filtrer par attribut, on utilise un filtre ECQL. Il s’agit d’un langage de requête très proche du SQL (ce qui vous utilisez sous QGIS pur filtrer vos données). Pour savoir comment filtrer vos données, il vous faut d’abord savoir quels sont les attributs de votre couche. Pour cela, on utilise la fonction get_wfs_attributes().\n\nget_wfs_attributes(\"BDTOPO_V3:commune\")\n\n [1] \"cleabs\"                             \"code_insee\"                        \n [3] \"code_insee_du_canton\"               \"code_insee_de_l_arrondissement\"    \n [5] \"code_insee_de_la_collectivite_terr\" \"code_insee_du_departement\"         \n [7] \"code_insee_de_la_region\"            \"population\"                        \n [9] \"superficie_cadastrale\"              \"date_creation\"                     \n[11] \"date_modification\"                  \"date_d_apparition\"                 \n[13] \"date_de_confirmation\"               \"code_postal\"                       \n[15] \"nom_officiel\"                       \"chef_lieu_d_arrondissement\"        \n[17] \"chef_lieu_de_collectivite_terr\"     \"chef_lieu_de_departement\"          \n[19] \"chef_lieu_de_region\"                \"capitale_d_etat\"                   \n[21] \"date_du_recensement\"                \"organisme_recenseur\"               \n[23] \"code_siren\"                         \"codes_siren_des_epci\"              \n[25] \"lien_vers_chef_lieu\"                \"liens_vers_autorite_administrative\"\n\n# On récupère guissény\ncom &lt;- get_wfs(layer = \"BDTOPO_V3:commune\", ecql_filter = \"code_insee = '29077'\")\n\nFeatures downloaded : 1\n\n\nUn fois que l’on a récupéré la commune, on peut récupérer les batiments qui intersectent la commune :\n\nbatiments &lt;- get_wfs(\n  x = com,\n  layer = \"BDTOPO_V3:batiment\",\n  spatial_filter = \"intersects\"\n)\n\nFeatures downloaded : 1000...2000...2742\n\n\n\n\nCode\nlibrary(ggspatial)\nlibrary(ggplot2)\nlibrary(sf)\n\nggplot() +\n  geom_sf(data = com) +\n  geom_sf(data = batiments, fill = \"red\") +\n  annotation_scale(location = \"br\") +\n  annotation_north_arrow(\n      location = \"tr\", which_north = \"true\",\n      style = north_arrow_fancy_orienteering\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n9.2.2 Fond de cartes à petite faible\nPour des fond de cartes à petites échelles, se tournera vers Natural Earth. Ce jeu de données enregistre les données élémentaires pour créer des fonds de cartes : frontières des pays, routes, cours d’eau, toponymie, zones urbaines, lacs, etc.\nLe package rnaturalearth permet de récupérer directement ces données sous R. Pour une carte du continent européen :\n\neurope &lt;- rnaturalearth::ne_countries(continent = \"Europe\", scale = \"large\")\n\nggplot() +\n  geom_sf(data = europe) +\n  theme_minimal()",
    "crumbs": [
      "Sources de données",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Où trouver des données</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TD analyse spatiale",
    "section": "",
    "text": "Informations\nEn TD :\n\nTD1 : Introduction à R\nTD2 : Analyse centrographique\nTD3 : Ségrégation spatiale\nTD4 : Réseaux, graphe et accessibilité\nTD5 : Mobilités et flux\n\nEn DM :\n\nDM1 : Analyse centrographique populations, logements, pauvreté\nDM2 : Modèle gravitaire sur flux de pop inter-régions",
    "crumbs": [
      "Informations"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_donnees.html",
    "href": "ressources/algorithmique/structure_donnees.html",
    "title": "4  Les structures de données",
    "section": "",
    "text": "4.1 Les variables\nLes structures de données de base sous R sont décrites dans la figure Figure 4.1.\nQuand on fait de l’analyse de données sous R, on est surtout confronté aux :\nLes arrays sont beaucoup moins courants.\nEn R, et dans les langages de programmation en générale, on stock des informations dans des objets sur lesquels on effectue des opérations. En R, l’objet de base est la variable1. Cette dernière peut être de différentes classes2. Les classes associées aux variables sont : numeric, character et logical.\nUne variable de classe numeric correspond à nombre ou un chiffre :\n# Définition de variables numeric\nn1 &lt;- 1\nn2 &lt;- 0.6\nn3 &lt;- -5.097\nn4 &lt;- 1e6 # Écriture scientifique\nOn assigne une valeur en utilisant &lt;- ou = (on utilisera le &lt;- de préférence car il est idiomatique). Les lignes commençant par # sont des commentaires. Ils sont extrêmements importants car ils vous permettent d’écrire librement du texte dans un script sans qu’il soit interprété comme du code. Vous pouvez ainsi documenter votre code pour faciliter sa lecture par ceux qui le liront.\nPour afficher le contenue d’un objet, on l’écrit dans la console ou on peut utiliser la fonction print() (imprimer) :\nn1\n\n[1] 1\n\nprint(n1)\n\n[1] 1\nPour vérifier la classe d’un objet, on utilise la fonction class() :\nclass(n1)\n\n[1] \"numeric\"\nLes variables de classe character enregistre une chaîne de caractères (comme un mot ou un code). Pour la définir, on encadre la valeur par des guillemets simples '' ou doubles \"\" (utilisez plutôt les guillemets doubles).\n# Définition de variables character\nc1 &lt;- \"a\"\nc2 &lt;- \"arbre\"\nc3 &lt;- \"Une chaîne de caractères plus longue\"\nc4 &lt;- \"LKJHNA2000\"\nc5 &lt;- \"1\"\nVous voyez qu’un chiffre peut être défini comme un caractère s’il est encadré de guillemets.\nEnfin, la classe logical correspond à des booléens : TRUE et FALSE.\nb1 &lt;- TRUE\nb2 &lt;- FALSE",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les structures de données</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_donnees.html#sec-variables",
    "href": "ressources/algorithmique/structure_donnees.html#sec-variables",
    "title": "4  Les structures de données",
    "section": "",
    "text": "1 Dans les faits, il s’agit d’un abus de langage. En R, tout est objet, donc une variable n’existe pas vraiment techniquement parlant. On utilise ce mot pour désigner les objets ne contenant qu’une seule valeur.2 Si vous avez déjà fait de la programmation Orientée Objet (OO), vous devez trouver cela étrange. En R, une classe n’est pas un objet au sens classique où on l’entend en OO mais une étiquette attachée à un un objet.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBien nommer ses objets\n\n\n\nComme pour l’écriture des noms de ses fichiers, il convient d’adopter une convention d’écriture que vous utiliserez dans tous vos scripts.\nEn R, il n’y a pas concenssus sur la convention à utiliser. Cependant, la majorité des personnes utilisent la snake case correspondant à : “tout en miniscule et espace en underscore”. C’est la convention que je vous conseil d’utiliser :\n\n\nBien\n\nma_variable\ndata_1\ndata_merged\n\n\nNaze\n\nMaVariable\nData.1\ndataMerged\n\n\n\nPersonnelement, j’enfreint cette convention pour les constantes que j’écrit en majuscule comme en python.",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les structures de données</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_donnees.html#sec-vector",
    "href": "ressources/algorithmique/structure_donnees.html#sec-vector",
    "title": "4  Les structures de données",
    "section": "4.2 Les vecteurs",
    "text": "4.2 Les vecteurs\nUn vecteur est un ensemble de variables de même classe. On le défini manuellement via la fonction c() (combine). Leur classe est similaire aux classes des variables.\n\n# Vecteur de type numeric\nvector_num &lt;- c(1, 2, 4, 5, 6)\nvector_num\n\n[1] 1 2 4 5 6\n\nclass(vector_num)\n\n[1] \"numeric\"\n\n# Vecteur de type character\nvector_str &lt;- c(\"pluie\", \"orage\", \"beau-temps\", \"pluie\", \"pluie\")\nvector_str\n\n[1] \"pluie\"      \"orage\"      \"beau-temps\" \"pluie\"      \"pluie\"     \n\nclass(vector_str)\n\n[1] \"character\"\n\n\nEn R, on a un type particulier de vecteur : les facteurs (factor). Il s’agit de vecteur de chaîne de caractère dont les modalités labelisées. Par défaut, les labels correspondent au nom des modalités elles-mêmes.\n\nvector_str &lt;- c(\"peu\", \"moyen\", \"beaucoup\", \"peu\", \"peu\")\n(factor_vector &lt;- factor(vector_str))\n\n[1] peu      moyen    beaucoup peu      peu     \nLevels: beaucoup moyen peu\n\n\nUn des intérêts des facteurs est que l’on peut leur donner des labels différents :\n\n(factor_vector_labelled &lt;- factor(\n    vector_str,\n    levels = c(\"peu\", \"moyen\", \"beaucoup\"),\n    labels = c(\"Pluiviosité faible\", \"Pluviosité moyenne\", \"Pluviosité forte\")\n))\n\n[1] Pluiviosité faible Pluviosité moyenne Pluviosité forte   Pluiviosité faible\n[5] Pluiviosité faible\nLevels: Pluiviosité faible Pluviosité moyenne Pluviosité forte\n\n\nOn peut traiter les facteurs de la même façon que les vecteurs de chaîne de caractères.\n\n4.2.1 Conversion de vecteurs\nOn peut convertir des vecteurs de la même façon que l’on convertie des variables avec les fonctions as.&lt;class&gt; (par-ex. as.numeric()).\n\n# Conversion d'un vecteur numérique vecteur de chaîne de caractères\n(vector_num_str &lt;- as.character(vector_num))\n\n[1] \"1\" \"2\" \"4\" \"5\" \"6\"\n\nclass(vector_num_str)\n\n[1] \"character\"\n\n(factor_vector &lt;- as.factor(vector_num_str))\n\n[1] 1 2 4 5 6\nLevels: 1 2 4 5 6\n\nclass(factor_vector)\n\n[1] \"factor\"",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les structures de données</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_donnees.html#sec-structure-df",
    "href": "ressources/algorithmique/structure_donnees.html#sec-structure-df",
    "title": "4  Les structures de données",
    "section": "4.3 Les Data frame et dérivées",
    "text": "4.3 Les Data frame et dérivées\nUn Data Frame (DF) est un tableau de données où chaque colonne correspond à un vecteur. Cela correspond à ce que vous traitez d’ordinaire sous excel.\nOn crée un Data frame avec la fonction data.frame :\n\n(df &lt;- data.frame(\n  taille = c(185, 166, 180, 164, 173),\n  prenom = c(\"Franz\", \"Richard\", \"Johan Sebastian\", \"Ella\", \"Maria\"),\n  nom = c(\"Litz\", \"Wagner\", \"Bach\", \"Fitzgerald\", \"Callas\")\n))\n\n  taille          prenom        nom\n1    185           Franz       Litz\n2    166         Richard     Wagner\n3    180 Johan Sebastian       Bach\n4    164            Ella Fitzgerald\n5    173           Maria     Callas\n\n\n\n4.3.1 Accès aux colonnes et aux lignes\nPour accéder à un vecteur (une colonne) dans un DF, plusieurs possibilités :\n\ndf$taille # Avec le $\ndf[[\"taille\"]] # avec [[]]\ndf[, \"taille\"] # avec la position\ndf[, 1] # avec l'index de la colonne\n\nOn utilise l’une ou l’autre des méthodes en fonction de la procédure que l’on est entrain d’employer. La méthode $ demeure la plus courante.\nPour accéder aux lignes, on utilise l’index de la ligne. Si le DF a des noms de lignes, on peut également utiliser ces noms.\n\n# Passer une colonne en nom de ligne\n(df &lt;- tibble::column_to_rownames(df, \"nom\"))\n\n           taille          prenom\nLitz          185           Franz\nWagner        166         Richard\nBach          180 Johan Sebastian\nFitzgerald    164            Ella\nCallas        173           Maria\n\n# Extraire la ligne par nom de ligne\ndf[\"Litz\", ]\n\n     taille prenom\nLitz    185  Franz\n\n\n\n\n4.3.2 Description d’un DF\nVous pouvez obtenir une description rapide de votre DF avec la fonction str(). Sur RStudio vous avez ces infos directement dans le panneau Environnement.\n\nstr(df)\n\n'data.frame':   5 obs. of  2 variables:\n $ taille: num  185 166 180 164 173\n $ prenom: chr  \"Franz\" \"Richard\" \"Johan Sebastian\" \"Ella\" ...\n\n\nDans le tableau ci-dessous, vous trouverez d’autres fonction qui permettent de décrire un DF.\n\n\n\n\n\n\n\n\nFonction\nPackage\nDescription\n\n\n\n\nstr()\nbase\nStructure générale, types des colonnes, aperçu des valeurs\n\n\nglimpse()\ndplyr\nÉquivalent de str() avec dplyr\n\n\nhead()\nbase\nPremières lignes (aperçu des données, pas structurel)\n\n\ntail()\nbase\nDernières lignes\n\n\nnames()\nbase\nNoms des colonnes\n\n\ndim()\nbase\nDimensions (lignes, colonnes)\n\n\nnrow()\nbase\nNombre de lignes\n\n\nncol()\nbase\nNombre de colonnes\n\n\n\n\n\n4.3.3 Les data frame spatiaux\nQuand on travail avec des données spatiales vectorielles, ce qui est le cas dans ce cours, on utilise une variante spatiale du Data frame qui est un objet sf issu du package sf.\n\n# Lecture d'un geopackage\npath &lt;- \"data/src/iris_29.gpkg\"\niris &lt;- sf::read_sf(path)\nclass(iris)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nIl s’agit d’un data.frame auquel une colonne qui enregistre la géométrie a été ajoutée. Cette colonne est souvent nommée geom ou geometry. L’objet sf enregistre également le système de coordonnées. Il est donc possible de réaliser des traitements spatiaux comme on le ferait sous QGIS.\n\n\n\n\n\n\nQuid des rasters\n\n\n\nIl est tout à fait possible de traiter des rasters sous R, notamment avec le package terra. Comme nous n’en utilisons pas dans ce cours, je ne m’étend pas sur le sujet.\n\n\n\n\n4.3.4 Données massives\nDans le cas de données massives, on pourra se tourner vers le package data.table qui possède sa propre syntaxe. Notez qu’on peut maintenant utilisez la syntaxe dplyr avec data.table en utilisant dtplyr ce qui est un très gros poulet.\n\nlibrary(data.table)\nlibrary(dtplyr)\n\n# Créer un objet\nldt &lt;- lazy_dt(mtcars)\n\nldt |&gt;\n  group_by(cyl) |&gt;\n  summarise(mpg = sum(mpg))\n\nSource: local data table [3 x 2]\nCall:   `_DT1`[, .(mpg = sum(mpg)), keyby = .(cyl)]\n\n    cyl   mpg\n  &lt;dbl&gt; &lt;dbl&gt;\n1     4  293.\n2     6  138.\n3     8  211.\n\n# Use as.data.table()/as.data.frame()/as_tibble() to access results",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les structures de données</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_donnees.html#les-matrices",
    "href": "ressources/algorithmique/structure_donnees.html#les-matrices",
    "title": "4  Les structures de données",
    "section": "4.4 Les matrices",
    "text": "4.4 Les matrices\nLes matrices sont notamment utilisées dans les fonctions orientées statistiques. C’est tout naturel car l’algèbre linéaire et les probabilités sont basées sur des tels objets mathématiques.\nPar exemple, dans le cas d’une régression linéaire dont les \\(\\beta\\) sont estimés par la méthode des moindres carrés ordinaires (OLS), les données sont stockées dans une matrice :\n\n# Génération de y\ny &lt;- mtcars$mpg\nX &lt;- model.matrix(mpg ~ ., data = mtcars)\n\n# Estimations des betas\nXtX_inv &lt;- solve(t(X) %*% X) # (X^T X)^(-1)\nXtY &lt;- t(X) %*% y            # (X^T y)\nbeta_hat &lt;- XtX_inv %*% XtY  # beta = (X^T X)^(-1) X^T y",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les structures de données</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_donnees.html#les-listes",
    "href": "ressources/algorithmique/structure_donnees.html#les-listes",
    "title": "4  Les structures de données",
    "section": "4.5 Les listes",
    "text": "4.5 Les listes\nVoilà une liste imbriquées (nested list) :\n\ngaziers &lt;- list(\n  \"Taylor Swift\" = list(\"argent\" = 30, \"niveau_de_poulet\"=1),\n  \"Bach\" = list(\"argent\" = 5, \"niveau_de_poulet\"=Inf),\n  \"Charlie Parker\" = list(\"argent\" = 1, \"niveau_de_poulet\"=1e6)\n)",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les structures de données</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_controle.html",
    "href": "ressources/algorithmique/structure_controle.html",
    "title": "3  Les structures de contrôle",
    "section": "",
    "text": "3.1 Les alternatives\nLes alternatives permettent d’effectuer une opération uniquement si une condition logique est remplie. L’alternative la plus couramment utilisée dans les langages de haut-niveau est le if-else.\nEn R, on utilise la syntaxe suivante :\nx &lt;- \"bleu\"\nif (x %in% c(\"bleu\", \"rouge\", \"jaune\")) {\n  cat(x, \"est une couleur primaire\\n\")\n} else {\n  cat(x, \"n'est pas une couleur primaire\\n\")\n}\n\nbleu est une couleur primaire\nLe if-else peut être étendu à plusieurs tests.\nCe qui en R donne :\nx &lt;- \"violet\"\nif (x %in% c(\"bleu\", \"rouge\", \"jaune\")) {\n  cat(x, \"est une couleur primaire\\n\")\n} else if (x %in% c(\"violet\", \"vert\", \"orange\")) {\n  cat(x, \"est une couleur secondaire\\n\")\n} else {\n  cat(x, \"n'est ni une couleur primaire, ni une couleur secondaire\\n\")\n}\n\nviolet est une couleur secondaire\nEn R, il existe une fonction pour le if-else :\nx &lt;- 1\nres &lt;- ifelse(\n  x &gt; 0,     # La condition\n  \"positif\", # Si vrai\n  \"négatif\"  # Sinon\n)\nprint(res)\n\n[1] \"positif\"",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les structures de contrôle</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_controle.html#les-alternatives",
    "href": "ressources/algorithmique/structure_controle.html#les-alternatives",
    "title": "3  Les structures de contrôle",
    "section": "",
    "text": "SI Test\n   Instruction 1\nSINON\n   Instruction 2\nFIN SI\n\n\n\nSI Test 1\n   Instruction 1\nSINONSI Test 2\n   Instruction 2\nSINON\n   Instruction 3\nFIN SI",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les structures de contrôle</span>"
    ]
  },
  {
    "objectID": "ressources/algorithmique/structure_controle.html#les-boucles",
    "href": "ressources/algorithmique/structure_controle.html#les-boucles",
    "title": "3  Les structures de contrôle",
    "section": "3.2 Les boucles",
    "text": "3.2 Les boucles\nLes boucles permettent d’effectuer des opérations plusieurs de fois de suite de manière controlée. Il y en a plusieurs sortes. Dans le cas de traitements de données sous R, vous serez surtout intéressé par la boucle de parcours qui est éxécutée sur chacun des éléments d’une liste.\nPOURCHAQUE valeur DANS collection\n   Instruction 1\nFIN POURCHAQUE\nEn R, cela se traduit par :\n\ncouleur_primaire &lt;- c(\"bleu\", \"rouge\", \"jaune\")\nfor (couleur in couleur_primaire) {\n  cat(couleur, \"\\n\")\n}\n\nbleu \nrouge \njaune \n\n\nOn peut réaliser des boucles imbriquées :\n\nsequence &lt;- 2:4\nfor (i in sequence) {\n  for (j in sequence) {\n    cat(i, \"/\", j, \"= \")\n    cat(i / j, \"\\n\")\n  }\n}\n\n2 / 2 = 1 \n2 / 3 = 0.6666667 \n2 / 4 = 0.5 \n3 / 2 = 1.5 \n3 / 3 = 1 \n3 / 4 = 0.75 \n4 / 2 = 2 \n4 / 3 = 1.333333 \n4 / 4 = 1 \n\n\nIl arrive que l’on veuille stopper la boucle au cours de son exécution ou tout simplement passer à l’élément suivant de la liste. Pour cela, on utilise les mots-clés break et next.\n\ncouleur_primaire &lt;- c(\"bleu\", \"rouge\", \"jaune\")\nfor (couleur in couleur_primaire) {\n  if (couleur == \"bleu\") {\n    cat(\"J'aime pas le\", couleur, \"je passe...\\n\")\n    next # passer à l'élément suivant\n  } else if (couleur == \"rouge\") {\n    cat(\"Du\", couleur, \"je panique !!! j'me tire...\\n\")\n    break # briser la boucle\n  }\n  cat(couleur, \"\\n\")\n}\n\nJ'aime pas le bleu je passe...\nDu rouge je panique !!! j'me tire...\n\n\nOn voit que jaune n’est jamais affiché car la boucle est brisée avant que le jaune puisse être affiché.\n\n3.2.1 purrr et la programmation fonctionnelle\n\npacman::p_load(purrr, dplyr)\n\nLes boucles for sont :\n\nVerbeuses (longues à écrire)\nSujettes à pas mal d’erreurs (error-prone)\nPeu performantes\n\nDans ce cadre, le package purrr a été conçu pour optimiser l’écriture de boucle dans un paradigme de programmation fonctionnelle. Pour faire simple, l’idée est que chaque étape du code est réalisée par l’appele d’une fonction qui ne retourne qu’un seul résultat.\nPour illustrer le principe, prenant un example de boucle qui, pour chaque valeur d’un vecteur numérique, calcul son carré et ajoute le résultat dans un vecteur préalablement instantié :\n\n# Définition de la donnée\nseq &lt;- 1:5\n\n# Instantiation d'un vecteur pour stocker les résultat\nres &lt;- vector()\n\n# La boucle\nfor (i in seq) {\n  # Calcul du carré\n  square &lt;- i ^ 2\n\n  # Stockage du résultat\n  res &lt;- c(res, square)\n}\n\nprint(res)\n\n[1]  1  4  9 16 25\n\n\nAvec purrr, l’opération est considérée comme l’application d’une fonction qui retourne une liste de valeurs. Cette liste est ensuite convertie en vecteur via list_c().\n\n# Définition de la donnée\nseq &lt;- 1:5\n\n# Application de la fonction\nres &lt;- map(seq, \\(i) i ^ 2) |&gt;\n    list_c() # conversion de la liste en vecteur\n\nprint(res)\n\n[1]  1  4  9 16 25\n\n\nPour rendre la chose encore plus claire, on pourrait écrire la fonction du carré et la passer directement à la fonction map() :\n\n# Fonction du carré\nsquare &lt;- function(x) {\n  return(x ^ 2)\n}\n\n# Définition de la donnée\nseq &lt;- 1:5\n\n# Application de la fonction\nres &lt;- map(seq, square) |&gt;\n    list_c() # conversion de la liste en vecteur\n\nprint(res)\n\n[1]  1  4  9 16 25\n\n\nAu final, le code est plus structuré, lisible et cohérent.\nPrenons un exemple plus parlant pour du traitement des données. Imaginons que l’on dispose de plusieurs data.frame dans une liste et que l’on souhaite réaliser une régression linéaire sur ces différentes sources de données et récupérer le \\(R^2\\) pour chacune.\n\n# Données d'entraînement de dplyr, séparée par CYL (4, 6 et 8)\ndata_list &lt;- split(mtcars, mtcars$cyl)\n\nr_squared &lt;-\n  # Application de la régression linéaire\n  map(data_list, \\(df) lm(mpg ~ wt, data = df)) |&gt;\n  # Application du résumé sur les objets lm\n  map(summary) |&gt;\n  # Récupérer les R2 sous forme de vecteur numérique nommée par valeur du CYL\n  map_dbl(\"r.squared\")\n\nprint(r_squared)\n\n        4         6         8 \n0.5086326 0.4645102 0.4229655 \n\n\nVous me direz qu’une fonction peut prendre plusieurs arguments en entrée. Effectivement, c’est pourquoi purrr dispose d’une fonction map2() qui itère sur 2 listes d’arguments simultanément. À plus de 2 listes d’arguments, on utilise la fonction pmap().\n\n# Ajusté des modèles linéaires\nmods &lt;- map(data_list, \\(df) lm(mpg ~ wt, data = df))\n\n# Faire une prédiction (predict()) avec les modèles préalablement ajustés (mods)\n# sur les données séparées (data_list)\nmap2(mods, data_list, predict)\n\n$`4`\n    Datsun 710      Merc 240D       Merc 230       Fiat 128    Honda Civic \n      26.47010       21.55719       21.78307       27.14774       30.45125 \nToyota Corolla  Toyota Corona      Fiat X1-9  Porsche 914-2   Lotus Europa \n      29.20890       25.65128       28.64420       27.48656       31.02725 \n    Volvo 142E \n      23.87247 \n\n$`6`\n     Mazda RX4  Mazda RX4 Wag Hornet 4 Drive        Valiant       Merc 280 \n      21.12497       20.41604       19.47080       18.78968       18.84528 \n     Merc 280C   Ferrari Dino \n      18.84528       20.70795 \n\n$`8`\n  Hornet Sportabout          Duster 360          Merc 450SE          Merc 450SL \n           16.32604            16.04103            14.94481            15.69024 \n        Merc 450SLC  Cadillac Fleetwood Lincoln Continental   Chrysler Imperial \n           15.58061            12.35773            11.97625            12.14945 \n   Dodge Challenger         AMC Javelin          Camaro Z28    Pontiac Firebird \n           16.15065            16.33700            15.44907            15.43811 \n     Ford Pantera L       Maserati Bora \n           16.91800            16.04103 \n\n\nEt avec pmap() :\n\nx &lt;- list(1, 1, 1)\ny &lt;- list(10, 20, 30)\nz &lt;- list(100, 200, 300)\n\npmap(list(x, y, z), \\(first, second, third) (first + third) * second)\n\n[[1]]\n[1] 1010\n\n[[2]]\n[1] 4020\n\n[[3]]\n[1] 9030\n\n\n\n\n\n\n\n\nImportant\n\n\n\nMême si la programmation fonctionnelle proposée par purrr est très attrayante, il demeure indispensable de savoir écrire une boucle classique. Il s’agit d’une des briques de base en programmation.\n\n\n\n\n\n\n\n\nQuid de lapply(), sapply(), etc.\n\n\n\nQuand vous ferez vos recherches sur internet, vous verrez souvent passer les fonctions lapply, sapply(), tapply() et autres apply(). Ces fonctions fonctionnent de manière assez similaires aux fonctions proposées par purrr mais viennent par défaut sous R.\nJe vous encourage à utiliser purrr car ses fonctions sont plus cohérentes entre elles. De plus, le package vient avec de nombreux “petits plus” très agréables au quotidien.\nSi vous êtes intéressés par la question, vous pouvez lire ce biais sur stackoverflow.\n\n\nRessources :\n\nblogpost pas mal sur purrr\nCheat sheet de purrr",
    "crumbs": [
      "Algorithmique",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Les structures de contrôle</span>"
    ]
  },
  {
    "objectID": "ressources/data_process/data_basic.html",
    "href": "ressources/data_process/data_basic.html",
    "title": "5  Traitement de données sous R",
    "section": "",
    "text": "5.1 Manipulation de Data Frames\nOn fera surtout du dplyr dans la mesure où la syntaxe est plus simple à appréhender que le base R.\nPrenons un example avec le jeu de données palmerpenguins.\nIl contient des informations sur trois espèces de manchots observées dans l’archipel de Palmer en Antarctique : Adelie, Chinstrap et Gentoo.\nAssurez-vous de bien comprendre la structure de données d’un Data Frame avant de lire cette section (cf. Section 3.3).",
    "crumbs": [
      "Traitements et analyse de données",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Traitement de données sous R</span>"
    ]
  },
  {
    "objectID": "ressources/data_process/data_basic.html#sec-manip-df",
    "href": "ressources/data_process/data_basic.html#sec-manip-df",
    "title": "5  Traitement de données sous R",
    "section": "",
    "text": "5.1.1 Lire et écrire des Data Frames\nPour lire des DF à partir de fichiers csv1, on utilise la fonction de R base read.csv() dont l’équivalent en tydiverse est la fonction read_csv() du package readr. Je vous conseil d’utiliser la fonction readr::read_csv() car elle plus optimiser que la première.\n1 On peut obtenir des DF à partir de fichiers autre que csv. Je me concentre sur ce format car il s’agit du plus courant. Si vous voulez lire des données à partir d’un fichier xls/xlsw vous pouvez utiliser le package read_excel. Je ne vous le conseil pas car les fichiers excel sont souvent très mal mis en forme en plus de contenir des feuilles. Il vaut mieux en extraire des csv propres.\n\n\n\n\n\nLe format csv\n\n\n\nLe format csv est un des formats les plus utilisé pour stocker des données tabulaires en data science. csv signifie Comma Separated Values (comma signifie virgule). Donc, dans la majorité des cas, un fichier csv sera de la forme :\nvar_1,var_2\n12,0.9\n2,0.25\n4,0.78\nEn Europe, on utilise souvent la virgule pour représenter le séparateur décimal. Le séparateur de valeurs du fichier csv devient alors le ;. Le fichier devient alors :\nvar_1;var_2\n12;0,9\n2;0,25\n4;0,78\nVous trouvez aussi des fichiers csv séparé par des tabulations (on parle de tsv. C’est surtout le cas pour les fichiers contenants du texte long car la virgule et le point virgule peuvent se rencontrer dans le texte.\n\n\n\n\n\n\n\n\nAttention\n\n\n\nUn fichier csv ne doit jamais avoir des informations avant la première ligne qui indique le nom des colonnes. Par exemple, le fichier suivant ne sera pas lu correctement.\nFichier écrit le 2025/05/02.\nvars_1 : longueur (cm)\nvars_2 : poid (g)\nvar_1;var_2\n12;0,9\n2;0,25\n4;0,78\nCela veut dire qu’un fichier csv ne doit contenir que les données et jamais les métadonnées ou autres informations. Bien évidemment, si vous écrivez des données et que vous voulez les partager il faut toujours écrire les métadonnées, mais vous les écrirez dans un fichier séparé.\n\n\nAvant de charger un fichier csv, il faut connaître le format employé : quel séparateur de valeur et quel séparateur de décimal est employé. Pour cela, il suffit d’ouvrir d’inspecter le fichier. Vous pouvez tout simplement essayer de l’ouvrir sous R et regarder le résultat. Sinon, vous pouvez ouvrir le fichier dans un logiciel externe (par exemple avec le notepad comme les csv sont des fichiers textuelles brutes).\n\n\n\n\n\n\n\n\n\nType de fichier\nSéparateur de colonnes\nSéparateur décimal\nFonction readr\n\n\n\n\nCSV standard\n,\n.\nread_csv()\n\n\nCSV2 (Europe)\n;\n,\nread_csv2()\n\n\nTSV\n\\t (tabulation)\n.\nread_tsv()\n\n\nALL\nargument delim\nargument locale (decimal_mark)\nread_delim()\n\n\n\nPar exemple :\n\npath &lt;- \"data/src/iris_brest.csv\"\ndf &lt;- readr::read_csv(path)\n\nRows: 90 Columns: 115\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (4): Libellé commune ou ARM, TRIRIS, Libellé de l'IRIS, Type d'IRIS\ndbl (111): IRIS, Région, Département, Unité urbaine, Commune ou ARM, Grand q...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nLa fonction readr::read_csv() renvoie directement des informations sur la classe des colonnes. Cela vous permet de voir rapidement si elles sont bien interprétées.\nPour écrire un fichier csv, vous pouvez utisez la fonction readr::write_csv(). Elle prend un data.frame en entrée et le chemin vers le fichier de destination. Je vous conseil d’utiliser la fonction avec les arguments par défaut, donc avec un séparateur virgule et un séparateur de décimale point. De cette façon, vous aurez toujours le format de csv et vous vous y retrouverez plus facilement.\n\noutput_path &lt;- \"data/res/output.csv\"\nreadr::write_csv(df_res, output_path)\n\n\n\n\n\n\n\nLire et écrire des données spatiales vectorielles\n\n\n\nQuand on travail avec des données spatiales vectorielles, ce qui est le cas dans ce cours, on utilise une variante spatiale du Data frame qui est un objet sf issu du package sf.\nAvec sf, on peut lire tous les types de fichiers spatiaux vectoriels (par-ex, shapefile, geopackage, etc.). On utilise la fonction read_sf().\n\n# Lecture d'un geopackage\npath &lt;- \"data/src/iris_29.gpkg\"\niris &lt;- sf::read_sf(path)\nclass(iris)\n\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nSi vous voulez lire un shapefile, vous indiquerez le chemin du fichier .shp, sf fera le lien avec les autres fichiers.\nOn écrit des données spatiales à partir d’un objet sf avec la fonction write_sf(). La fonction “devine” le format attendu à partir de l’extension que vous donnez au fichier :\n\n# Écriture d'un fichier geopackage\npath &lt;- \"data/res/output.gpkg\"\nsf::write_sf(sf_res, path)\n\n\n\n\n\n5.1.2 Un framework pour la manipulation de données : dplyr\ndplyr est un framework du tidyverse en R conçu pour faciliter la manipulation de données de manière claire, cohérente et efficace. Il repose sur une syntaxe intuitive et un petit ensemble de verbes cohérents qui correspondent aux opérations les plus courantes en analyse de données, comme :\n\nselect() pour choisir des colonnes,\nfilter() pour filtrer les lignes,\nmutate() pour créer ou modifier des variables,\nsummarise() pour résumer les données,\narrange() pour trier les observations,\net group_by() pour travailler par groupes.\n\nCes verbes peuvent être reliés les uns aux autres par un pipe (|&gt; ou %&gt;%). Ce dernier prend le résultat de la fonction précédente comme tableau d’enttrée. Par exemple :\n\npenguins |&gt;\n    select(island, species, bill_len, year) |&gt;\n    filter(year &gt; 2007) |&gt;\n    group_by(island, species) |&gt;\n    summarise(mean_bill_len = mean(bill_len, na.rm = TRUE))\n\n`summarise()` has grouped output by 'island'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 3\n# Groups:   island [3]\n  island    species   mean_bill_len\n  &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;\n1 Biscoe    Adelie             39.2\n2 Biscoe    Gentoo             47.7\n3 Dream     Adelie             38.2\n4 Dream     Chinstrap          48.9\n5 Torgersen Adelie             39.0\n\n\n\n\n5.1.3 Sélectionner, filtrer, modifier et trier\n\n5.1.3.1 Sélectionner des données\nPour sélectionner une variable spécifique, on utilise la fonction homonime select().\n\nselected &lt;- select(penguins, species, island, body_mass)\nhead(selected)\n\n  species    island body_mass\n1  Adelie Torgersen      3750\n2  Adelie Torgersen      3800\n3  Adelie Torgersen      3250\n4  Adelie Torgersen        NA\n5  Adelie Torgersen      3450\n6  Adelie Torgersen      3650\n\n\nÀ l’inverse, pour supprimer des variables, on place un - devant la variable :\n\nselected &lt;- select(penguins, -species, -island, -body_mass)\nhead(selected)\n\n  bill_len bill_dep flipper_len    sex year\n1     39.1     18.7         181   male 2007\n2     39.5     17.4         186 female 2007\n3     40.3     18.0         195 female 2007\n4       NA       NA          NA   &lt;NA&gt; 2007\n5     36.7     19.3         193 female 2007\n6     39.3     20.6         190   male 2007\n\n\nOn peut employer une expression de sélection pour choisir des variables par rapport à une condition. Par exemple, si on veut sélectionner toutes les variables dont le nom se termine par une chaine de caractère précise, on peut utiliser la fonction ends_with() dans la fonction select() :\n\nselected &lt;- select(penguins, ends_with(\"len\"))\nhead(selected)\n\n  bill_len flipper_len\n1     39.1         181\n2     39.5         186\n3     40.3         195\n4       NA          NA\n5     36.7         193\n6     39.3         190\n\n\n\n\n\n\n\n\nPlus d’examples\n\n\n\n\n\nSi on a une idée précise des variables que l’on veut sélectionner, on peut utiliser un vecteur de contenant les noms des variables et utiliser la fonction all_of() :\n\nto_select &lt;- c(\"island\", \"species\", \"body_mass\")\nselected &lt;- select(penguins, all_of(to_select))\nhead(selected)\n\n     island species body_mass\n1 Torgersen  Adelie      3750\n2 Torgersen  Adelie      3800\n3 Torgersen  Adelie      3250\n4 Torgersen  Adelie        NA\n5 Torgersen  Adelie      3450\n6 Torgersen  Adelie      3650\n\n\nBien sûr, on peut les combiner :\n\nselected &lt;- select(penguins, starts_with(\"bill\"), where(is.factor))\nhead(selected)\n\n  bill_len bill_dep species    island    sex\n1     39.1     18.7  Adelie Torgersen   male\n2     39.5     17.4  Adelie Torgersen female\n3     40.3     18.0  Adelie Torgersen female\n4       NA       NA  Adelie Torgersen   &lt;NA&gt;\n5     36.7     19.3  Adelie Torgersen female\n6     39.3     20.6  Adelie Torgersen   male\n\n\n\n\n\nVoilà un tableau récapitulatif des expressions les plus communes que l’on peut utiliser pour sélectionner des variables.\n\n\n\n\n\n\n\n\n\nFonction\nDescription\nExemple\n\n\n\n\n\nstarts_with(\"x\")\nSélectionne les variables dont le nom commence par \"x\"\nselect(starts_with(\"Sepal\"))\n\n\n\nends_with(\"x\")\nSélectionne les variables dont le nom se termine par \"x\"\nselect(ends_with(\"Width\"))\n\n\n\ncontains(\"x\")\nSélectionne les variables dont le nom contient \"x\"\nselect(contains(\"Petal\"))\n\n\n\nall_of(vars)\nSélectionne toutes les colonnes listées dans un vecteur vars (et renvoie une erreur si une manque)\nselect(all_of(c(\"Species\", \"Sepal.Length\")))\n\n\n\neverything()\nSélectionne toutes les colonnes (utile pour repositionner)\nselect(Species, everything())\n\n\n\nwhere(predicate)\nSélectionne selon un type ou une condition logique sur les colonnes\nselect(where(is.numeric)), select(where(~mean(.) &gt; 0))\n\n\n\n\n\n\n5.1.3.2 filtrer des données\nPour filtrer les données avec dplyr on utilise la fonction homonyme filter(). Cette dernière filtre les lignes par vérification de conditions.\nPar exemple, si on veut récupérer uniquement les donnnées pour l’espèce Adelie :\n\nfiltered &lt;- filter(penguins, species == \"Adelie\")\nhead(filtered)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n\n\nOu si on souhaite récupérer les observations pour les années postérieur à 2007.\n\nfiltered &lt;- filter(penguins, year &gt; 2007)\nhead(filtered)\n\n  species island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Biscoe     39.6     17.7         186      3500 female 2008\n2  Adelie Biscoe     40.1     18.9         188      4300   male 2008\n3  Adelie Biscoe     35.0     17.9         190      3450 female 2008\n4  Adelie Biscoe     42.0     19.5         200      4050   male 2008\n5  Adelie Biscoe     34.5     18.1         187      2900 female 2008\n6  Adelie Biscoe     41.4     18.6         191      3700   male 2008\n\n\nOn peut combiner les filtres :\n\nfiltered &lt;- filter(penguins, year &gt; 2007, species == \"Adelie\")\nhead(filtered)\n\n  species island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Biscoe     39.6     17.7         186      3500 female 2008\n2  Adelie Biscoe     40.1     18.9         188      4300   male 2008\n3  Adelie Biscoe     35.0     17.9         190      3450 female 2008\n4  Adelie Biscoe     42.0     19.5         200      4050   male 2008\n5  Adelie Biscoe     34.5     18.1         187      2900 female 2008\n6  Adelie Biscoe     41.4     18.6         191      3700   male 2008\n\n\nSouvent, on faire sélectionner des données dans une gamme de valeurs, il suffit de faire :\n\nfiltered &lt;- filter(penguins, bill_len &gt; 35, bill_len &lt; 40)\nhead(filtered)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n3  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n4  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n5  Adelie Torgersen     38.9     17.8         181      3625 female 2007\n6  Adelie Torgersen     39.2     19.6         195      4675   male 2007\n\n\n\n\n\n\n\n\nPlus d’examples\n\n\n\n\n\nPlutôt que d’utiliser des virgules pour séparer les filtres on peut utiliser une syntaxe booléenne (je ne vous le conseil pour débuter) :\n\nfiltered &lt;- filter(\n    penguins,\n    (\n        (species == \"Gentoo\" | species == \"Adelie\") &\n        body_mass &gt; mean(body_mass, na.rm = TRUE)\n    )\n)\nhead(filtered)\n\n  species    island bill_len bill_dep flipper_len body_mass  sex year\n1  Adelie Torgersen     39.2     19.6         195      4675 male 2007\n2  Adelie Torgersen     42.0     20.2         190      4250 &lt;NA&gt; 2007\n3  Adelie Torgersen     34.6     21.1         198      4400 male 2007\n4  Adelie Torgersen     42.5     20.7         197      4500 male 2007\n5  Adelie     Dream     39.8     19.1         184      4650 male 2007\n6  Adelie     Dream     44.1     19.7         196      4400 male 2007\n\n\nPour filter les modalités de facteurs ou de chaines de caractères, on peut utiliser l’opérateur %in%.\n\nfiltered &lt;- filter(penguins, species %in% c(\"Gentoo\", \"Adelie\"))\nhead(filtered)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n\n\nPour récupérer l’inverse d’une condition, on utilise le point d’exclamation !.\n\nfiltered &lt;- filter(penguins, !species %in% c(\"Gentoo\", \"Adelie\"))\nhead(filtered)\n\n    species island bill_len bill_dep flipper_len body_mass    sex year\n1 Chinstrap  Dream     46.5     17.9         192      3500 female 2007\n2 Chinstrap  Dream     50.0     19.5         196      3900   male 2007\n3 Chinstrap  Dream     51.3     19.2         193      3650   male 2007\n4 Chinstrap  Dream     45.4     18.7         188      3525 female 2007\n5 Chinstrap  Dream     52.7     19.8         197      3725   male 2007\n6 Chinstrap  Dream     45.2     17.8         198      3950 female 2007\n\n\n\n\n\nTableau récapitulatif\n\n\n\n\n\n\n\n\n\n\nCatégorie\nFonction / opérateur\nDescription\nExemple\n\n\n\n\nComparaison numérique\n==, !=\nÉgal / différent\nfilter(Species == \"setosa\")\n\n\n\n&gt;, &lt;, &gt;=, &lt;=\nSupérieur, inférieur, etc.\nfilter(Sepal.Length &gt; 6)\n\n\nAppartenance\n%in%\nAppartient à un ensemble de valeurs\nfilter(Species %in% c(\"setosa\", \"virginica\"))\n\n\n\n!x %in% ...\nN’appartient pas à…\nfilter(!Species %in% \"setosa\")\n\n\nTexte / chaînes\nstr_detect(x, \"mot\")\nContient un motif (nécessite stringr)\nfilter(str_detect(Species, \"osa\"))\n\n\n\nstartsWith(x, \"mot\")\nCommence par…\nfilter(startsWith(Species, \"set\"))\n\n\n\nendsWith(x, \"mot\")\nSe termine par…\nfilter(endsWith(Species, \"ica\"))\n\n\nValeurs manquantes\nis.na(x)\nEst manquant\nfilter(is.na(Sepal.Length))\n\n\n\n!is.na(x)\nN’est pas manquant\nfilter(!is.na(Sepal.Length))\n\n\nIntervalles\nbetween(x, a, b)\nValeur comprise entre a et b (inclusif)\nfilter(between(Sepal.Length, 5, 6))\n\n\nConditions complexes\nif_else() ou logique combinée\nChoix conditionnels\nfilter(if_else(Sepal.Width &gt; 3, TRUE, FALSE))\n\n\n\n\n\n\n5.1.3.3 Modifier des données\nPour modifier des données ou en rajouter, on utilise la fonction mutate().\nPar exemple, si on veut faire un arrondi de la variable bill_len.\n\nmutated &lt;- mutate(penguins, bill_len = round(bill_len))\nhead(mutated$bill_len)\n\n[1] 39 40 40 NA 37 39\n\n\nPlutôt que d’écrire par-dessus la variable bill_len, on peut vouloir créer une autre variable pour enregistrer la modification. On écrit simplement le nom de la nouvelle variable à gauche du = :\n\nmutated &lt;- mutate(penguins, bill_len_round = round(bill_len))\nhead(mutated$bill_len_round)\n\n[1] 39 40 40 NA 37 39\n\n\nOn peut faire des opérations qui utilisent plusieurs variables :\n\nmutated &lt;- mutate(penguins, bill_len_norm_mass = bill_len / body_mass)\nhead(mutated$bill_len_norm_mass)\n\n[1] 0.01042667 0.01039474 0.01240000         NA 0.01063768 0.01076712\n\n\nOn peut modifier de façon conditionnelle nos variables. Par exemple, si on veut arrondir uniquement la variable bill_len pour les espèces Adelie alors, on peut utiliser la fonction ifelse() :\n\nmutated &lt;- mutate(\n    penguins,\n    bill_len_round = ifelse(species == \"Adelie\", round(bill_len), bill_len)\n)\n\nQuand on a plus d’une condition à vérifier, on privilégiera la fonction case_when() :\n\nmutated &lt;- mutate(\n    penguins,\n    geo_code = case_when(\n        island == \"Biscoe\" ~ \"North\",\n        island == \"Torgersen\" ~ \"Midlle\",\n        TRUE ~ \"South\" # quand les deux premières ne sont pas vérifiées\n    )\n)\n\nSi on souhaite modifier un ensemble de variables répondant à un ou des caractères communs, on peut utiliser la fonction across(). Par exemple, si on veut arrondir toutes les variables numériques, on écrira :\n\nmutated &lt;- mutate(penguins, across(where(is.numeric), ~round(.x)))\nhead(mutated)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen       39       19         181      3750   male 2007\n2  Adelie Torgersen       40       17         186      3800 female 2007\n3  Adelie Torgersen       40       18         195      3250 female 2007\n4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n5  Adelie Torgersen       37       19         193      3450 female 2007\n6  Adelie Torgersen       39       21         190      3650   male 2007\n\n\nIl arrive que l’on souhaite modifier des variables ou en créer de nouvelles par groupe. Par exemple, on peut vouloir normaliser bill_len par la moyenne de body_mass par espèce. Dans ce cadre, on utilisera la fonction group_by() qui permet d’effectuer des opérations par groupe.\n\nmutated &lt;- penguins |&gt;\n    group_by(species) |&gt;\n    mutate(norm_bill_len = bill_len / mean(body_mass))\n\n\n\n5.1.3.4 Trier les données\nPour trier les données, on utilise la fonction arrange(). Par exemple, si on veut ordonner le tableau par bill_len :\n\narranged &lt;- arrange(penguins, bill_len)\nhead(arranged)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie     Dream     32.1     15.5         188      3050 female 2009\n2  Adelie     Dream     33.1     16.1         178      2900 female 2008\n3  Adelie Torgersen     33.5     19.0         190      3600 female 2008\n4  Adelie     Dream     34.0     17.1         185      3400 female 2008\n5  Adelie Torgersen     34.1     18.1         193      3475   &lt;NA&gt; 2007\n6  Adelie Torgersen     34.4     18.4         184      3325 female 2007\n\n\nPar défaut l’ordre est croissant. Pour trier de façon décroissante, on utilise place la fonction desc() sur la variable :\n\narranged &lt;- arrange(penguins, desc(bill_len))\nhead(arranged)\n\n    species island bill_len bill_dep flipper_len body_mass    sex year\n1    Gentoo Biscoe     59.6     17.0         230      6050   male 2007\n2 Chinstrap  Dream     58.0     17.8         181      3700 female 2007\n3    Gentoo Biscoe     55.9     17.0         228      5600   male 2009\n4 Chinstrap  Dream     55.8     19.8         207      4000   male 2009\n5    Gentoo Biscoe     55.1     16.0         230      5850   male 2009\n6    Gentoo Biscoe     54.3     15.7         231      5650   male 2008\n\n\nOn peut bien sûr trier par plusieurs variables :\n\narranged &lt;- arrange(penguins, desc(year), desc(body_mass))\nhead(arranged)\n\n  species island bill_len bill_dep flipper_len body_mass  sex year\n1  Gentoo Biscoe     48.8     16.2         222      6000 male 2009\n2  Gentoo Biscoe     49.8     15.9         229      5950 male 2009\n3  Gentoo Biscoe     55.1     16.0         230      5850 male 2009\n4  Gentoo Biscoe     50.4     15.7         222      5750 male 2009\n5  Gentoo Biscoe     49.5     16.1         224      5650 male 2009\n6  Gentoo Biscoe     50.8     17.3         228      5600 male 2009\n\n\nLes données qualitatives sont triées par ordre alphabétique de la première lettre de la chaîne de caractères :\n\narranged &lt;- arrange(penguins, desc(island))\nhead(arranged)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n\n\n\n\n\n5.1.4 Aggrégation de données\nL’agrégation consiste à regrouper des observations selon une ou plusieurs variables (catégories, dates, régions, etc.) afin de calculer des indicateurs synthétiques (moyenne, total, écart-type, etc.) pour chaque groupe. C’est ce qui vous faites sur excel quand vous créez un tableau croisé dynamique.\nEn traitement et analyse de données, il s’agit d’une des opérations les plus courantes.\n\n5.1.4.1 Aggrégation de l’ensemble d’un jeu de données\n\n# On utilise le jeu de données palmerpenguins\ndata(package = 'palmerpenguins')\nhead(penguins)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n\npenguins &lt;- tidyr::drop_na(penguins)\n\nImaginons que l’on souhaite calculer la moyenne pour la variable bill_len et la variable flipper_len et conserver le résultat dans un data.frame. La solution de base serait :\n\ndata.frame(\n    mean_bill_len = mean(penguins$bill_len),\n    mean_flipper_len = mean(penguins$flipper_len)\n)\n\n  mean_bill_len mean_flipper_len\n1      43.99279          200.967\n\n\nMaintenant, si on voulait calculer la moyenne pour tous les variables numériques, il faudrait réécrire quatre fois la même ligne. Ce n’est pas efficient. En R base, on utiliserait une boucle pour pallier ces redondances. dplyr a été conçu pour faciliter l’écriture dans ces cas là. Pour résumer un jeu de données on utilise la fonction summarise(). Pour obtenir le même résultat que précédemment, on écrira :\n\nsummarise(\n    penguins,\n    mean_bill_len = mean(bill_len),\n    mean_flipper_len = mean(flipper_len)\n)\n\n  mean_bill_len mean_flipper_len\n1      43.99279          200.967\n\n\nJusque là, ça ne nous avance pas à grand chose, si ce n’est que l’on plus obligé d’utiliser les $ pour accéder aux variables. Là où ça devient intéressant, c’est bien quand on a beaucoup de variables à résumer. Dans ce cas, on peut sélectionner les variables à résumer en utilisant la fonction across() qui permet prend une condition à vérifier et une opération à effectuer sur les variables retenues. Par exemple, si comme précédemment on souhaite calculer la moyenne pour tous les variables numériques, on écrira :\n\nsummarise(penguins, across(where(is.numeric), ~mean(.x)))\n\n  bill_len bill_dep flipper_len body_mass     year\n1 43.99279 17.16486     200.967  4207.057 2008.042\n\n\nUne seul ligne de code permet de faire cela. Et si on souhaite également calculer d’autres statistiques ? C’est aussi possible ! Par exemple, si on souhaite également calculer la médiane et l’écart-type :\n\nsummarise(penguins, across(\n    # Uniquement sur les variables numériques sauf la variable year\n    where(is.numeric) & !year,\n    # Quelles fonctions appliquer\n    .fn = list(mean = mean, median = median, sd = sd),\n    # Quelles noms de variables renvoyer\n    .names = \"{.col}_{.fn}\" # .col est le nom de la var. et .fn le nom de la function\n))\n\n  bill_len_mean bill_len_median bill_len_sd bill_dep_mean bill_dep_median\n1      43.99279            44.5    5.468668      17.16486            17.3\n  bill_dep_sd flipper_len_mean flipper_len_median flipper_len_sd body_mass_mean\n1    1.969235          200.967                197       14.01577       4207.057\n  body_mass_median body_mass_sd\n1             4050     805.2158\n\n\nTrès bien, mais cela ne s’applique que pour un jeu de données entier. Comment faire si l’on souhaite calculer ces statistiques pour des groupes ?\n\n\n5.1.4.2 Aggrégation par groupe\nPour aggréger des données par groupe en utilisant dplyr il suffit d’employer la fonction group_by() avec summarise(). Le reste du code ne change pas. Dans group_by(), on indique la ou les variables de regroupement. Par exemple, pour calculer la moyenne pour toutes les variables numériques sauf year par espèces et par îles :\n\npenguins |&gt;\n    group_by(species, island) |&gt;\n    summarise(across(where(is.numeric) & !year, ~mean(.x)))\n\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 6\n# Groups:   species [3]\n  species   island    bill_len bill_dep flipper_len body_mass\n  &lt;fct&gt;     &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n1 Adelie    Biscoe        39.0     18.4        189.     3710.\n2 Adelie    Dream         38.5     18.2        190.     3701.\n3 Adelie    Torgersen     39.0     18.5        192.     3709.\n4 Chinstrap Dream         48.8     18.4        196.     3733.\n5 Gentoo    Biscoe        47.6     15.0        217.     5092.\n\n\n\n\n\n\n\n\nbase R\n\n\n\n\n\nEn R base, pour effectuer une aggrégation par groupe on utilisera la fonction aggregate(). Par exemple, pour calculer la moyenne de toutes les variables numériques dans iris\n\naggregate(\n    penguins[, sapply(penguins, is.numeric)], # seule les variables numeriques\n    by = list(Species = penguins$species), # la variable qui contient les groupes\n    FUN = mean # La fonction\n)\n\n    Species bill_len bill_dep flipper_len body_mass     year\n1    Adelie 38.82397 18.34726    190.1027  3706.164 2008.055\n2 Chinstrap 48.83382 18.42059    195.8235  3733.088 2007.971\n3    Gentoo 47.56807 14.99664    217.2353  5092.437 2008.067\n\n\n\n\n\n\n\n\n5.1.5 Jointure de données\nPour faire des jointures, on s’appuira sur le package dplyr et ses fonctions *_join() (c.f. doc). Ces dernières permettent une approche intuitive des jointures, mimant le comportement des jointures en SQL.\n\n\n\nJoin in dplyr\n\n\nImaginons que nous disposons de deux jeux de données. Le premier contient le code postal et le nom de commune française. Le deuxième recèle la population et le code postal. On souhaite joindre les deux données pour disposer au sein d’un même tableau le code postal, le nom des communes et leur population.\n\ndt1 &lt;- data.frame(\n    code = c(29120, 29200, 29600, 29160),\n    commune = c(\"Pont-L'abbé\", \"Brest\", \"Morlaix\", \"Crozon\")\n)\nprint(dt1)\n\n   code     commune\n1 29120 Pont-L'abbé\n2 29200       Brest\n3 29600     Morlaix\n4 29160      Crozon\n\ndt2 &lt;- data.frame(\n    code = c(29120, 29200, 29600, 29880),\n    pop = c(140993, 8403, 15220, 6719)\n)\nprint(dt2)\n\n   code    pop\n1 29120 140993\n2 29200   8403\n3 29600  15220\n4 29880   6719\n\n\nPour effectuer une jointure, il faut disposer d’une variable commune entre les deux tableaux. Dans notre cas, il s’agit de la variable code. On peut alors effectuer quatre jointure différentes :\n\nlibrary(dplyr)\n\nleft_join(dt1, dt2, by = \"code\") # garde toutes les lignes de dt1\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29200       Brest   8403\n3 29600     Morlaix  15220\n4 29160      Crozon     NA\n\nright_join(dt1, dt2, by = \"code\") # garde toutes les lignes de dt2\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29200       Brest   8403\n3 29600     Morlaix  15220\n4 29880        &lt;NA&gt;   6719\n\ninner_join(dt1, dt2, by = \"code\") # garde uniquement les codes communs\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29200       Brest   8403\n3 29600     Morlaix  15220\n\nfull_join(dt1, dt2, by = \"code\") # garde toutes les lignes des deux\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29200       Brest   8403\n3 29600     Morlaix  15220\n4 29160      Crozon     NA\n5 29880        &lt;NA&gt;   6719\n\n\nAu quotidien, on emploie le plus souvent le left_join().\nSouvent, on dispose de la même variable dans deux jeux de données mais nommée différemment. Dans ce cas soit :\n\nOn renomme la variable dans un des tableaux puis on joint normalement ;\nOn change l’argument by par by = c(\"var_dt1\" = \"var_dt2\").\n\n\n\n\n\n\n\nbase R\n\n\n\n\n\nEn base R, on utilise merge() avec différents paramètres pour obtenir le même résultat :\n\nmerge(dt1, dt2, by = \"code\", all.x = TRUE) # left join\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29160      Crozon     NA\n3 29200       Brest   8403\n4 29600     Morlaix  15220\n\nmerge(dt1, dt2, by = \"code\", all.y = TRUE) # right join\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29200       Brest   8403\n3 29600     Morlaix  15220\n4 29880        &lt;NA&gt;   6719\n\nmerge(dt1, dt2, by = \"code\") # inner join (par défaut)\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29200       Brest   8403\n3 29600     Morlaix  15220\n\nmerge(dt1, dt2, by = \"code\", all = TRUE) # full join\n\n   code     commune    pop\n1 29120 Pont-L'abbé 140993\n2 29160      Crozon     NA\n3 29200       Brest   8403\n4 29600     Morlaix  15220\n5 29880        &lt;NA&gt;   6719",
    "crumbs": [
      "Traitements et analyse de données",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Traitement de données sous R</span>"
    ]
  },
  {
    "objectID": "ressources/data_process/data_basic.html#manipulation-de-matrice",
    "href": "ressources/data_process/data_basic.html#manipulation-de-matrice",
    "title": "5  Traitement de données sous R",
    "section": "5.2 Manipulation de matrice",
    "text": "5.2 Manipulation de matrice\nBien que les data.frame (et objets associés) soit les objets les plus courants que vous aurez à traiter, il arrive que l’on se retrouve à traiter des matrices (matrix). Ces objets, plus simples dans leur structure que les Dataframe, sont souvent utilisés pour optimiser des traitements.\n\n5.2.1 Les bases des matrices sous R\n\n5.2.1.1 Création de matrices\nOn peut créer une matrice avec la fonction matrix() :\n\n# Création d'une matrice 3x3 remplie par colonnes\nm1 &lt;- matrix(1:9, nrow = 3, ncol = 3)\nm1\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# On peut aussi remplir par lignes\nm2 &lt;- matrix(1:9, nrow = 3, byrow = TRUE)\nm2\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\n\n\n5.2.1.2 Accès aux éléments\nOn peut accéder aux éléments de la matrice de la même façon que dans un dataframe en utilisant l’indice des lignes et des colonnes.\n\nm1[2, 3] # Élément de la 2e ligne, 3e colonne\n\n[1] 8\n\nm1[1, ] # 1ère ligne complète\n\n[1] 1 4 7\n\nm1[, 2] # 2e colonne complète\n\n[1] 4 5 6\n\n\nSi les lignes et/ou les colonnes sont nommées, on peut également utiliser les noms pour retrouver les valeurs.\n\ncolnames(m1) &lt;- paste0(\"c\", 1:3)\nrownames(m1) &lt;- paste0(\"r\", 1:3)\nm1[\"r1\", \"c3\"]\n\n[1] 7\n\n\n\n\n5.2.1.3 Opérations sur les matrices\nLes opérations arithmétiques sont vectorisées.\n\nm1 + 10 # Ajout d'une constante\n\n   c1 c2 c3\nr1 11 14 17\nr2 12 15 18\nr3 13 16 19\n\nm1 * 2  # Multiplication élément par élément\n\n   c1 c2 c3\nr1  2  8 14\nr2  4 10 16\nr3  6 12 18\n\nm1 ^ 2  # Carré de chaque élément\n\n   c1 c2 c3\nr1  1 16 49\nr2  4 25 64\nr3  9 36 81\n\n\nPour les multiplications matricielles\n\nm1 * m2 # produit de hadamard (élément par élément)\n\n   c1 c2 c3\nr1  1  8 21\nr2  8 25 48\nr3 21 48 81\n\nm1 %*% m2 # produit scalaire (dot product)\n\n   [,1] [,2] [,3]\nr1   66   78   90\nr2   78   93  108\nr3   90  108  126\n\nm1[1, ] %o% m1[2, ] # produit extérieur (outer product)\n\n   c1 c2 c3\nc1  2  5  8\nc2  8 20 32\nc3 14 35 56\n\n\nIl est également possible de calculer des statistiques pour les lignes et les colonnes :\n\nrowSums(m1)\n\nr1 r2 r3 \n12 15 18 \n\nrowMeans(m1)\n\nr1 r2 r3 \n 4  5  6 \n\ncolSums(m1)\n\nc1 c2 c3 \n 6 15 24 \n\ncolMeans(m1)\n\nc1 c2 c3 \n 2  5  8 \n\n\n\n\n5.2.1.4 Autres opérations\n\nt(m1) # Transposée\n\n   r1 r2 r3\nc1  1  2  3\nc2  4  5  6\nc3  7  8  9\n\ndet(m1) # Déterminant\n\n[1] 0\n\ndiag(m1) # Diagonale\n\n[1] 1 5 9",
    "crumbs": [
      "Traitements et analyse de données",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Traitement de données sous R</span>"
    ]
  },
  {
    "objectID": "ressources/data_process/data_basic.html#traitement-de-chaîne-de-caractères",
    "href": "ressources/data_process/data_basic.html#traitement-de-chaîne-de-caractères",
    "title": "5  Traitement de données sous R",
    "section": "5.3 Traitement de chaîne de caractères",
    "text": "5.3 Traitement de chaîne de caractères\nRéférences :\n\nLe chapitre les chaînes de caractères de guide-R (Larmarange, 2025)\n\n\n5.3.1 Chercher/remplacer\nPour chercher remplacer dans une chaîne de caractère (variable ou vecteur), on utiliser la fonction de base gsub() ou la fonction stringr::str_replace().\n\n# Avec une chaîne de caractère\nx &lt;- \"Une phras mal orthographié\"\nx &lt;- gsub(x = x, \"phras\", \"phrase\")\ngsub(x = x, \"orthographié\", \"orthographiée\")\n\n[1] \"Une phrase mal orthographiée\"\n\n# Avec un vecteur\nx &lt;- c(\"Puie\", \"pluie\", \"ORag_\", \"Orage\")\nx &lt;- gsub(x = x, \"Puie\", \"pluie\")\ngsub(x = x, \"ORag_\", \"orage\")\n\n[1] \"pluie\" \"pluie\" \"orage\" \"Orage\"\n\n\nTout l’intérêt de passer par un langage de programmation est de pouvoir automatiser au maximum le remplacement des chaînes de caractère. Pour cela, on utilise les expressions régulières (on dira plutôt regex). Ces dernières permettent d’identifier efficacement des schémas dans des chaînes de caractères. Imaginons que l’on souhaite supprimer tous les espaces qui sont placés au début d’une chaîne de caractère dans un vecteur :\n\nx &lt;- c(\"Michel Legrand\", \"Glenn Gould\", \" Michel Legrand\", \" Glenn Gould\")\n# Quatre valeur unique alors qu'on souhaite en avoir 2.\nunique(x)\n\n[1] \"Michel Legrand\"  \"Glenn Gould\"     \" Michel Legrand\" \" Glenn Gould\"   \n\n# Supprimer les espaces situés au début de la chaîne de caractère\nx &lt;- gsub(x = x, \"^ \", \"\")\nunique(x)\n\n[1] \"Michel Legrand\" \"Glenn Gould\"   \n\n\nOn peut également mouvoir des bouts de chaînes en utilisant des groupes. Supposons que l’on veuille passer les noms avant les prénoms :\n\nx &lt;- c(\"Michel Legrand\", \"Glenn Gould\", \"Michel Legrand\", \"Glenn Gould\")\ngsub(x = x, \"^(.*(?= )) (.*$)\", \"\\\\2 \\\\1\", perl = TRUE)\n\n[1] \"Legrand Michel\" \"Gould Glenn\"    \"Legrand Michel\" \"Gould Glenn\"   \n\n\nLes expressions régulières ne sont pas forcément facile à manipuler mais quand on commence à les prendre en main on gagne un temps fou. Vous pouvez vous renseigner ici.\n\n\n\nQuand vous commencez à maitriser un peu les regex\n\n\n\n\n5.3.2 Concaténation\nPour concaténer deux chaînes de caractères :\n\nlibrary(glue)\n\nstr1 &lt;- \"un chêne\"\nstr2 &lt;- \"vouvre\"\n\n# Méthode 1: paste() et paste0()\nconc1 &lt;- paste(str1, str2) # espace par défaut entre les deux chaînes\nconc2 &lt;- paste0(str1, \" \", str2)\n\n# Méthode 2: sprintf()\nconc3 &lt;- sprintf(\"%s %s\", str1, str2)\n\n# Méthode 3: glue()\nconc4 &lt;- glue(\"{str1} {str2}\")\n\nprint(conc4)\n\nun chêne vouvre\n\nall(c(conc1, conc2, conc3) == conc4)\n\n[1] TRUE\n\n\nglue() est la méthode la plus moderne, elle est à privilégier.\n\n\n5.3.3 Tableau de contingence\nPour calculer un tableau de contingence sous R, on utilise la fonction table() avec les deux vecteurs que l’on souhaite analyser.\n\ntable(penguins$species, penguins$island)\n\n           \n            Biscoe Dream Torgersen\n  Adelie        44    55        47\n  Chinstrap      0    68         0\n  Gentoo       119     0         0",
    "crumbs": [
      "Traitements et analyse de données",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Traitement de données sous R</span>"
    ]
  },
  {
    "objectID": "00_intro_r/intro_r.html",
    "href": "00_intro_r/intro_r.html",
    "title": "1  Introduction à R et RStudio",
    "section": "",
    "text": "1.1 RStudio\nComme dans la majorité des langages interprétés, quand on installe R, une console interactive est installée en même temps. Vous pouvez y accéder en cherchant R dans vos programmes ou en effectuant les opérations ctrl+R (ouvrir l’exécuteur de commmande) &gt; R &gt; enter. C’est comme quand vous ouvrez un terminal powershell sous Windows, sauf qu’au lieu d’écrire du powershell, vous écrivez du R.\nDans l’absolu, on pourrait écrire nos scripts dans la console directement mais ce serait très peu pratique. Aussi, quand on code, on utilise un Environnement de Développement (IDE en anglais), et ce, quelque soit le langage que l’on utilise. Ces derniers intègrent des tas de fonctionnalités pour vous simplifier la vie (colorisation du code, diagnostique automatique des erreurs de syntaxe, outils intégrés de visualisation, etc.). Il y en a beaucoup. Certains sont génériques (ils supportent de nombreux langages) comme Visual Studio Code ou spécifique, destiné à un seul langage, comme c’est le cas de RStudio pour R.\nIl s’agit de l’IDE le plus utilisé pour faire du R, et de très très loin. Il est open-source et fréquemment mis à jour.",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction à R et RStudio</span>"
    ]
  },
  {
    "objectID": "00_intro_r/intro_r.html#rstudio",
    "href": "00_intro_r/intro_r.html#rstudio",
    "title": "1  Introduction à R et RStudio",
    "section": "",
    "text": "1.1.1 Création d’un projet\n\n1.1.1.1 Organiser son dossier de travail\nLa première chose à faire quand on commence un projet, quelqu’il soit, c’est de se créer un espace de travail cohérent ou vous vous retrouverez facilement. Ce dernier doit être le plus généralisable possible, de telle sorte à ce que vous puissiez le réemployer pour d’autres projets. De cette façon, vous ne serez plus jamais perdus dans vos fichiers et vous gagnerez un temps considérable. Pour de l’analyse/traitement de données, je vous conseil la configuration suivante :\n\n📁 ./data/: là où vous stockerez vos données\n\n📁 ./data/src/: Les données sources\n📁 ./data/res/: Les données créées par vos scripts\n\n📁 ./docs/: là où vous enregistrerez vos documents words par exemple.\n📁 ./figures/: là où vous enregistrerez vos graphs, cartes, ect.\n📁 ./scripts/: vos scripts R\n\nLe ./ fait référence à la racine du dossier : le chemin du dossier dans lequel les dossiers ci-dessus sont enregistrés. Cette racine peut être située où vous le souhaitez sur votre machine.\n\n\n\n\n\n\nBien nommer ses fichiers\n\n\n\nPourquoi est-ce important ?\n\nPour ne pas vous demander à chaque fois pendant trois plombes comment vous allez écrire un nom de fichier ou de dossier.\nEncore une fois pour avoir une organisation nickel.\nPour éviter de vous retrouver avec des erreurs liées à des espaces ou des caractères spéciaux.\n\nAussi, je vous conseil d’adopter une convention d’écriture. Il y en a plein, vous pouvez inventer la vôtre tant qu’elle est cohérente. Il est notamment important de proscrire tous les signes diacritiques (é, è, ç, à, etc.), les espaces et les signes (/, %, $, etc.). Je vous conseil la convention qui consiste à n’écrire qu’en minuscule, sans caractères spéciaux et en replaçant les espaces par des underscores (_).\nPar exemple :\n\n\nBien\ntd0_introduction_r.R\nrendu_20250506_analyse_spatiale.R\ngraph_epervier.png\n\nNaze\nTD 0 Introduction à R .R\nRendu_2025/05/06_AnalyseSpatiale.R\nGraphique épervier.png\n\n\n\n\n\n\n1.1.1.2 Créer un projet RStudio\nUne fois que vous avez créé votre espace de travail dans votre explorateur de fichier, procédez aux opérations suivantes pour créer un projet RStudio.\n\n\n\n\n\n\nInstructions\n\n\n\n\nOuvrez RStudio\nCréez un nouveau projet : Fichier &gt; Nouveau projet &gt; Répertoire existant. Indiquez le dossier que vous avez créé précédemment.\nCréez un nouveau script R : Fichier &gt; Nouveau fichier &gt; Script R. Enregistrez-le (ctrl+s).\n\n\n\n\n\n\n1.1.2 L’interface\n\n\n\n\n\n\nFigure 1.1: Interface de RStudio\n\n\n\nL’interface fonctionne avec des panneaux que l’on peut changer au besoin dans les préférences du logiciel1. Par défaut, on a l’organisation de la Figure 1.1.\n1 Affichage&gt;Volet&gt;Options de mise en page des volets\nA):\n\nDans ce panneau, vous avez vos scripts R. C’est ici que vous écrirez.\n\nB):\n\nConsole: La console R. La même console interactive que quand on ouvre R sans RStudio.\nTerminal: Le terminal de votre machine. Sous Windows du ???.\nTravaux: Des jobs que vous faites tourner en arrière-plan.\n\nC):\n\nEnvironnement: La liste des objets de la session courante.\nHistorique: L’historique des commandes introduites dans la console R.\nConnexions: Connexions à des bases de données externes.\nTutoriel: tutos\n\nD):\n\nFichiers: Un explorateur de fichier (comme l’explorateur de fichier windows)\nGraphiques: Un espace où les graphs seront affichés.\nPaquets: Liste de packages, vous pouvez les installer depuis cet onglet.\nAide: Onglet où sont affichés les documentations des fonctions que vous utilisez.\nVisualisateur: Onglet d’affichage des graphs 3D, des pages webs, etc.\nPrésentation: Onglet dédié aux présentations.\n\n\nIl existe d’autres panneaux que l’on peut rajouter à l’interface au besoin. Vous aurez surtout besoin de la console, de l’environnement, de l’onglet graphique et aide.",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction à R et RStudio</span>"
    ]
  },
  {
    "objectID": "00_intro_r/intro_r.html#les-bases-de-r-pour-le-traitement-de-données",
    "href": "00_intro_r/intro_r.html#les-bases-de-r-pour-le-traitement-de-données",
    "title": "1  Introduction à R et RStudio",
    "section": "1.2 Les bases de R pour le traitement de données",
    "text": "1.2 Les bases de R pour le traitement de données\n\n\n\n\n\n\nOrganiser son script R\n\n\n\nPour ne pas se perdre dans son code et garantir sa reproductibilité, il convient de l’organiser soigneusement.\nUn exemple typique de script en analyse de données est le suivant :\n\nChargement des packages. C’est toujours la première chose à faire.\nÉcriture des constantes (si nécessaire)\nChargement des données\nPré-traitement des données (nettoyage, merge, etc.)\nL’analyse que l’on souhaite effectuer (le cœur du script)\nAnalyse des résultats (graphs, résumés, etc.)\n\nPour bien se retrouver dans le script, on peut tirer parti des commentaires et créer des titres et des sous-titres. Par exemple :\n\n################################################################################\n# Titre 1 ----\n################################################################################\n## Sous titre 1.1 --------------------------------------------------------------\n# Commentaire classique\n\n### Sous titre 1.1.1 -----------------------------------------------------------\n# Commentaire classique\n\n################################################################################\n# Titre 2 ----\n################################################################################\n## Sous titre 2.1 --------------------------------------------------------------\n# code etc.\n\nNotez que RStudio identifie automatiquement les commentaires suivis d’un minimum de quatre caractères similaire (- ou #) comme des niveaux de titre. Pour définir le niveau, il faut ajuster le nombre de # avant le titre (# h1, ## h2, etc.). Pour vous rendre d’une section à une autre dans votre script, vous pouvez utiliser le navigateur situé en bas à gauche de l’onglet script.\n\n\n\n\n\n\n\n\nInstruction\n\n\n\nLisez l’introduction du Chapter 4.\n\n\n\n1.2.1 Les variables\n\n\n\n\n\n\nInstruction: variable\n\n\n\nLisez la Section 4.1.\n\nCréez des variables de classe différente\n\n\n\nCode\n# Variables numériques\na &lt;- 1\nb &lt;- 0.6\nclass(a)\n## [1] \"numeric\"\n\n# Variable \"character\"\nc &lt;- \"texte\"\nd &lt;- \"Une autre variable\"\nclass(c)\n## [1] \"character\"\n\n\n\nEssayez d’effectuer des opérations mathématiques entre des variables de différentes classes. Qu’observez-vous ?\n\n\n\nCode\n# Opérations\na / b\n## [1] 1.666667\na * b\n## [1] 0.6\n\n# On ne peut pas faire d'opérations entre une variable numérique et une chaîne\n# de caractère\na + c\n## Error in a + c: non-numeric argument to binary operator\n\n\n\n\n\n\n1.2.2 Les vecteurs\n\n\n\n\n\n\nInstructions : vecteurs\n\n\n\nLisez la Section 4.2.\nVecteur numérique :\n\nEffectuer des opérations entre deux vecteurs numériques de même longeur : que constatez-vous ?\n\n\n\nCode\n# Définition des vecteurs\na &lt;- c(1, 5, 10, 6)\nb &lt;- c(2, 2, 3, 4)\n\n# Opérations sur les vecteurs\na / b\n## [1] 0.500000 2.500000 3.333333 1.500000\na * b\n## [1]  2 10 30 24\n\n# Les opérations sont effectuées élément par éléments (par-ex. pour a/b : 1/2,\n# 5/2, etc.)\n\n\n\nEffectuer des opérations entre une variable numérique et un vecteur numérique: que constatez-vous ?\n\n\n\nCode\n# Variable numérique\ns &lt;- 2\n\n# Opérations entre la variable et un vecteur\ns * a\n## [1]  2 10 20 12\na / s\n## [1] 0.5 2.5 5.0 3.0\ns / a\n## [1] 2.0000000 0.4000000 0.2000000 0.3333333\n\n# La variable numérique est appliquée à tous les éléments du vecteur via\n# l'opération choisie (et inversement)\n\n\n\nCalculer des statistiques élémentaires sur ces vecteurs (cf. Section 5.1.1).\n\n\n\nCode\nmean(a)\n## [1] 5.5\nmedian(a)\n## [1] 5.5\nsd(a)\n## [1] 3.696846\nmin(a)\n## [1] 1\nmax(a)\n## [1] 10\n\n\nVecteur de chaîne de caractères : (aidez vous de la Section 5.1.2)\n\nvector_str &lt;- c(\"A\", \"a\", \"b\", \"b\", \"B\", \"C\", \"C\")\n\n\nQuels sont les modalités du vecteur vector_str ?\n\n\n\nCode\nunique(vector_str)\n## [1] \"A\" \"a\" \"b\" \"B\" \"C\"\n\n\n\nCombien y a-t-il de valeurs associées à chacune de ces modalités ?\n\n\n\nCode\ntable(vector_str)\n## vector_str\n## a A b B C \n## 1 1 2 1 2\n\n\n\n\n\n\n1.2.3 Les tableaux de données : les Data Frames\n\n\n\n\n\n\nInstruction : création de Data Frame\n\n\n\nLisez la Section 4.3.\n\nCréez un DF de à partir de quatre vecteurs de longueur 5 (2 numériques, 2 de chaîne caractères).\n\n\n\nCode\n# Définition des vecteurs\na &lt;- c(2, 5, 8, 9, 10)\nb &lt;- c(0.2, 0.5, 0.8, 0.1, 0.6)\nc &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nd &lt;- c(\"banane\", \"pomme\", \"pêche\", \"framboise\", \"fraise\")\n\n# Définition du data.frame\ndf &lt;- data.frame(\n  colonne1 = a,\n  colonne2 = b,\n  colonne3 = c,\n  colonne4 = d\n)\ndf\n##   colonne1 colonne2 colonne3  colonne4\n## 1        2      0.2        A    banane\n## 2        5      0.5        B     pomme\n## 3        8      0.8        C     pêche\n## 4        9      0.1        D framboise\n## 5       10      0.6        E    fraise\nclass(df)\n## [1] \"data.frame\"\n\n\n\nAccédez à des colonnes et à des lignes. Récupérez le nombre de lignes et de colonnes\n\n\n\nCode\n# Accéder à des colonnes\ndf$colonne1\n## [1]  2  5  8  9 10\ndf$colonne3\n## [1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\n# Accéder à des lignes\ndf[1, ]\n##   colonne1 colonne2 colonne3 colonne4\n## 1        2      0.2        A   banane\ndf[2, ]\n##   colonne1 colonne2 colonne3 colonne4\n## 2        5      0.5        B    pomme\n\n# Nombre de lignes\nnrow(df)\n## [1] 5\n\n# Nombre de colonnes\nncol(df)\n## [1] 4\n\n\n\n\n\n\n\n\n\n\nLes packages\n\n\n\nUn package est un ensemble de code prêt à l’emploi que vous pouvez charger dans votre session R. Vous pouvez les voir comme des “extensions”.\nLa première chose à faire est d’installer le package sur votre machine. Pour cela, on emploie la fonction de base install.packages(\"&lt;le nom du package&gt;\"). Par exemple :\n\n# Pour installer le package palmerpenguins\ninstall.packages(\"palmerpenguins\")\n\nCette opération télécharge le package et l’installe sur votre PC. Une fois le package installé, il faut le charger dans la session R courante. Pour cela, on emploie la fonction library(&lt;nom du package&gt;).\n\n# On charge palmerpenguins\nlibrary(palmerpenguins)\n\nIl n’est pas nécessaire d’installer le package plusieurs fois, une seule suffit. En revanche, il vous faudra charger le package à chaque nouvelle session R si vous voulez l’utiliser.\n\n\n\n\n\n\n\n\nInstructions : manipulation de Data Frame\n\n\n\nVous apprendrez avec un jeu de données d’entraînement issu du package palmerpenguins2.\n\nInstaller et charger le package palmerpenguins\n\n\n# Charge un DF nommé penguins dans la session courante\ndata(package = \"palmerpenguins\")\nhead(penguins)\n\n  species    island bill_len bill_dep flipper_len body_mass    sex year\n1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n\n\nCommencez par décrire brièvement le tableau de données :\n\nNombre d’observations\nNombre de variables (leur type)\n\n\n\nCode\n# Nombre de lignes et de colonnes\nnrow(penguins)\n## [1] 344\nncol(penguins)\n## [1] 8\n\n# Le type des variables (e.g. Factor, num, int, etc.)\nstr(penguins)\n## 'data.frame':    344 obs. of  8 variables:\n##  $ species    : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ island     : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ bill_len   : num  39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n##  $ bill_dep   : num  18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n##  $ flipper_len: int  181 186 195 NA 193 190 181 195 193 190 ...\n##  $ body_mass  : int  3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n##  $ sex        : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n##  $ year       : int  2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n\n\nPour les opérations suivantes, appuyez-vous sur la Section 5.1. Vous vous appuierez sur le package dplyr.\n\nSélection des variables : select()\n\nSélectionner les variables island et bill_len.\nSélectionner uniquement les variables numériques.\nSélectionner toutes les variables qualitatives sauf island.\n\n\n\n\nCode\n# install.packages(\"dplyr\") # Installer le package si besoin\n# Charge le package dplyr\nlibrary(dplyr)\n\n# Exercice 1 ------------------------------------------------------------------\nsel_1 &lt;- select(penguins, island, bill_len)\nhead(sel_1)\n##      island bill_len\n## 1 Torgersen     39.1\n## 2 Torgersen     39.5\n## 3 Torgersen     40.3\n## 4 Torgersen       NA\n## 5 Torgersen     36.7\n## 6 Torgersen     39.3\n\n# Équivalent à\nsel_1 &lt;- penguins |&gt;\n    select(island, bill_len)\n\n# Exercice 2 ------------------------------------------------------------------\nsel_2 &lt;- select(penguins, where(is.numeric))\nhead(sel_2)\n##   bill_len bill_dep flipper_len body_mass year\n## 1     39.1     18.7         181      3750 2007\n## 2     39.5     17.4         186      3800 2007\n## 3     40.3     18.0         195      3250 2007\n## 4       NA       NA          NA        NA 2007\n## 5     36.7     19.3         193      3450 2007\n## 6     39.3     20.6         190      3650 2007\n\n# Équivalent à\nsel_2 &lt;- penguins |&gt;\n    select(where(is.numeric))\n\n# Exercice 3 ------------------------------------------------------------------\nsel_3 &lt;- select(penguins, where(is.factor), -island)\nhead(sel_3)\n##   species    sex\n## 1  Adelie   male\n## 2  Adelie female\n## 3  Adelie female\n## 4  Adelie   &lt;NA&gt;\n## 5  Adelie female\n## 6  Adelie   male\n\n# Équivalent à\nsel_3 &lt;- penguins |&gt;\n    select(where(is.factor), -island)\n\n\n\nFiltrer les observations : filter()\n\nNe conserver que les pingouins Adélie de l’île de Biscoe qui sont des mâles.\nPour l’année 2007, ne conserver que les pingouins dont la masse est supérieure à la moyenne.\nRetirez les lignes contenant des valeurs manquantes.\n\n\n\n\nCode\n# Exercice 1 ------------------------------------------------------------------\nfilt_1 &lt;- filter(penguins, species == \"Adelie\", island == \"Biscoe\", sex == \"male\")\nhead(filt_1)\n##   species island bill_len bill_dep flipper_len body_mass  sex year\n## 1  Adelie Biscoe     37.7     18.7         180      3600 male 2007\n## 2  Adelie Biscoe     38.2     18.1         185      3950 male 2007\n## 3  Adelie Biscoe     38.8     17.2         180      3800 male 2007\n## 4  Adelie Biscoe     40.6     18.6         183      3550 male 2007\n## 5  Adelie Biscoe     40.5     18.9         180      3950 male 2007\n## 6  Adelie Biscoe     40.1     18.9         188      4300 male 2008\n\n# Exercice 2 ------------------------------------------------------------------\nfilt_2 &lt;- filter(penguins, year == 2007, body_mass &gt; mean(body_mass, na.rm = TRUE))\nhead(filt_2)\n##   species    island bill_len bill_dep flipper_len body_mass  sex year\n## 1  Adelie Torgersen     39.2     19.6         195      4675 male 2007\n## 2  Adelie Torgersen     42.0     20.2         190      4250 &lt;NA&gt; 2007\n## 3  Adelie Torgersen     34.6     21.1         198      4400 male 2007\n## 4  Adelie Torgersen     42.5     20.7         197      4500 male 2007\n## 5  Adelie     Dream     39.8     19.1         184      4650 male 2007\n## 6  Adelie     Dream     44.1     19.7         196      4400 male 2007\n\n# Exercice 3 ------------------------------------------------------------------\n# install.packages(\"tidyr\") # Installer le package si besoin\nlibrary(tidyr)\nfilt_3 &lt;- drop_na(penguins)\nhead(filt_3)\n##   species    island bill_len bill_dep flipper_len body_mass    sex year\n## 1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n## 2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n## 3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n## 4  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n## 5  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n## 6  Adelie Torgersen     38.9     17.8         181      3625 female 2007\n\n# Équivalent à (en R base) :\nfilt_3 &lt;- na.omit(penguins)\n\n\n\nCréer et modifier des variables : mutate()\n\nConvertissez l’unité des nageoires ‘flipper_len’ en cm.\nCréer un indicateur correspondant à la longueur du bec (bill_len) divisée par sa profondeur (bill_dep).\n\n\n\n\nCode\n# Exercice 1 ------------------------------------------------------------------\nmut_1 &lt;- mutate(penguins, flipper_len_cm = flipper_len / 10)\nhead(mut_1)\n##   species    island bill_len bill_dep flipper_len body_mass    sex year\n## 1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n## 2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n## 3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n## 4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n## 5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n## 6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n##   flipper_len_cm\n## 1           18.1\n## 2           18.6\n## 3           19.5\n## 4             NA\n## 5           19.3\n## 6           19.0\n\n# Exercice 2 ------------------------------------------------------------------\nmut_2 &lt;- mutate(penguins, len_div_dep = bill_len / bill_dep)\nhead(mut_2)\n##   species    island bill_len bill_dep flipper_len body_mass    sex year\n## 1  Adelie Torgersen     39.1     18.7         181      3750   male 2007\n## 2  Adelie Torgersen     39.5     17.4         186      3800 female 2007\n## 3  Adelie Torgersen     40.3     18.0         195      3250 female 2007\n## 4  Adelie Torgersen       NA       NA          NA        NA   &lt;NA&gt; 2007\n## 5  Adelie Torgersen     36.7     19.3         193      3450 female 2007\n## 6  Adelie Torgersen     39.3     20.6         190      3650   male 2007\n##   len_div_dep\n## 1    2.090909\n## 2    2.270115\n## 3    2.238889\n## 4          NA\n## 5    1.901554\n## 6    1.907767\n\n\n\nRésumé de DF : summarise()/group_by()\n\nCalculer la médiane et l’amplitude de bill_len.\nCalculer la médiane de chaque variable numérique.\nCalculer la médiane de la longueur du bec par espèce.\nCalculer la médiane de la longueur du bec par espèce et par sexe.\n\n\n\n\nCode\n# Exercice 1 ------------------------------------------------------------------\n# Supprimer les NAs\npenguins &lt;- na.omit(penguins)\n# Calculer la médiane et l'amplitude\nsuma_1 &lt;- summarise(\n    penguins,\n    med_bill_len = median(bill_len),\n    range_bill_len = range(bill_len)\n)\nsuma_1\n##   med_bill_len range_bill_len\n## 1         44.5           32.1\n## 2         44.5           59.6\n\n# Exercice 2 ------------------------------------------------------------------\nsuma_2 &lt;- summarise(penguins, across(where(is.numeric), ~mean(.x)))\nsuma_2\n##   bill_len bill_dep flipper_len body_mass     year\n## 1 43.99279 17.16486     200.967  4207.057 2008.042\n\n# Exercice 3 ------------------------------------------------------------------\nsuma_3 &lt;- penguins |&gt;\n    group_by(species) |&gt;\n    summarise(med_bill_len = median(bill_len))\nsuma_3\n## # A tibble: 3 × 2\n##   species   med_bill_len\n##   &lt;fct&gt;            &lt;dbl&gt;\n## 1 Adelie            38.8\n## 2 Chinstrap         49.6\n## 3 Gentoo            47.4\n\n# Exercice 4 ------------------------------------------------------------------\nsuma_4 &lt;- penguins |&gt;\n    group_by(species, sex) |&gt;\n    summarise(med_bill_len = median(bill_len))\nsuma_4\n## # A tibble: 6 × 3\n## # Groups:   species [3]\n##   species   sex    med_bill_len\n##   &lt;fct&gt;     &lt;fct&gt;         &lt;dbl&gt;\n## 1 Adelie    female         37  \n## 2 Adelie    male           40.6\n## 3 Chinstrap female         46.3\n## 4 Chinstrap male           51.0\n## 5 Gentoo    female         45.5\n## 6 Gentoo    male           49.5\n\n\n\nJointure de données :\n\nTéléchargez et chargez les données : (cf. Section 5.1.1)\n\nDonnées géographiques : iris_29.gpkg (cliquez ici pour télécharger la donnée).\nDonnées INSEE : iris_brest.csv (cliquez ici pour télécharger la donnée ; vous verrez le fichier .csv brut dans le navigateur. Enregistrez le sur votre PC à l’endroit approprié).\n\nJoignez la donnée spatiale aux données INSEE (cf. Section 5.1.5).\n\n\n\n\n2 Certains packages possèdent des données d’exemple qui sont téléchargées sur votre PC au moment de l’installation du package. On peut les charger dans la session R courant avec la fonction data().\n\n\n\n\n\nInstructions bonus\n\n\n\n\n\nDonnées : penguins du package palmerpenguins\n\nCalculez la masse moyenne par espèce.\nCalculez le nombre de pingouins par île et par an.\nPour les pingouins Adélie, quel sexe est le plus représenté ?\nQuelle est la masse moyenne (en kilo) des femelles Adélie de l’île de Torgersen ?\nExiste-t-il une différence de la longueur moyenne du bec entre les différentes espèces (attention comparé ce qui est comparable (sexe)).\n\nDonnées : starwars du package dplyr.\n\nQuels sont les personnages de Star-Wars qui ont les cheveux noirs ?\nQui est le personnage le plus grand ?\nQui est le personnage le plus vieux ?\nQuel est le genre le plus représenté ?\nQuelle est la planète d’origine la plus représentée ?\nQuelle est la taille moyenne des personnages originaires de Tatooine (comparé ce qui est comparable : sexe, espèce, etc.). Donnez le résultat en mètre.\nParmi les personnages originaires de Naboo, quelle est la couleur de cheveux la plus représentée.\n\nExercice jointure : données issues du package Lahman. Regardez le schéma de la base de données dans la description du package. Vous remarquerez que les tables (les tableaux de données) sont associées les unes aux autres par des ID.\n\nQui est le joueur qui a joué le plus de matchs dans sa carrière ?\n\nVous utiliserez la table People et la table Batting. Regardez la documentation du package pour voir quel nom de colonne correspond à quoi.\nIl y a beaucoup de colonnes, pensez à ne sélectionner que celles qui vous intéressent.\nPour obtenir le résultat final, il faudra agréger ;)\n\nRécupérer le nom des écoles auxquelles chacun des joueurs (table People) a été rattaché au cours de sa carrière.\n\nIl vous faudra passer par la table CollegePlaying pour récupérer l’ID des écoles. Le nom des écoles est disponible dans la table Schools. Il y a donc deux jointures à faire.\nIl y a beaucoup de colonnes, pensez à ne sélectionner que celles qui vous intéressent.\n\n\n\n\n\n\n\n1.2.4 Références\nCheat sheet :\n\nRStudio\nBase R\ndplyr",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction à R et RStudio</span>"
    ]
  },
  {
    "objectID": "01_points/semi_points.html",
    "href": "01_points/semi_points.html",
    "title": "2  Analyse centrographique",
    "section": "",
    "text": "2.1 Formulation du problème et cadre de l’analyse\nL’objectif de ce TD est de mettre en lumière l’intérêt de l’analyse centrographique pour évaluer des tendances spatio-temporelles. Nous utilisons l’exemple de la dynamique spatiale de la répartition de la population des États-Unis depuis 1790.\nQuestionnement : quelle est la dynamique spatiale de la population des États-Unis depuis la fin du 18e siècle ? (le questionnement s’intéresse donc à un processus spatio-temporel)\nType de démarche : descriptive. Ici, on ne s’intéresse qu’à la description du phénomène, il n’est pas question de prouver le pourquoi : il ne s’agit pas de modélisation à visé explicative.\nMéthode :\nIci, je vous donne la méthode. Il va de soit qu’en dehors du TD, vous devrez trouvez vous-même les méthodes appropriées à la résolution de votre questionnement (en lisant la littérature scientifique).",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Analyse centrographique</span>"
    ]
  },
  {
    "objectID": "01_points/semi_points.html#formulation-du-problème-et-cadre-de-lanalyse",
    "href": "01_points/semi_points.html#formulation-du-problème-et-cadre-de-lanalyse",
    "title": "2  Analyse centrographique",
    "section": "",
    "text": "La méthode d’analyse spatiale qui permet l’identification de la localisation moyenne d’entités spatiales est l’analyse centrographique. (dimension spatial)\nPour évoluer la tendance temporelle de cette localisation moyenne, il faut évaluer cette localisation au cours du temps. (dimension temporelle)",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Analyse centrographique</span>"
    ]
  },
  {
    "objectID": "01_points/semi_points.html#données",
    "href": "01_points/semi_points.html#données",
    "title": "2  Analyse centrographique",
    "section": "2.2 Données",
    "text": "2.2 Données\nPour répondre au questionnement et au vu de la méthode retenue, il faut trouver une donnée qui enregistre la population des États-Unis à une échelle spatiale cohérente et sur un pas de temps régulier (pour évaluer la tendance temporelle). En temps normal, vous devrez trouvez vous-même la donnée (si elle existe), ici je vous la donne directement.\nLe recensement de la population des États-Unis est réalisé pour la première fois en 1790, conformément à la Constitution américaine, qui exige qu’un dénombrement de la population soit effectué tous les dix ans. Son objectif initial était politique : déterminer la représentation de chaque État au Congrès et répartir l’impôt fédéral selon la population. Très vite, le recensement est aussi devenu un outil administratif et économique, permettant de connaître la distribution de la population et l’essor des territoires. Organisé par le Census Bureau, il constitue aujourd’hui l’une des plus longues séries statistiques au monde.\nLa donnée est disponible sur le site du Census Bureau. Elle est mise à disposition dans un format inexploitable en l’état. Sur Kaggle, on trouve le jeu de données correctement sous un format tidy, c’est la donnée que nous utiliserons. Le jeu de données dispose de trois variables : state, year et population.\n\n\nCode\nreadr::read_csv(\"data/src/us_population_by_state.csv\", show_col_types = FALSE) |&gt;\nreactable::reactable(\n    searchable = TRUE,\n    filterable = TRUE,\n    striped = TRUE,\n    highlight = TRUE,\n    bordered = TRUE,\n    defaultPageSize = 10,\n    theme = reactablefmtr::nytimes()\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nInstructions\n\n\n\nChargez le jeu de données avec la fonction readr::read_csv() (c.f. Section 5.1.1). Téléchargez la donnée en cliquant ici.\n\n\nCode\n# Read pop data\ndt &lt;- read_csv(\"data/src/us_population_by_state.csv\")\n## Rows: 6579 Columns: 3\n## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (1): state\n## dbl (2): year, population\n## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nÀ ce stade vous disposez de presque toutes les données nécessaires : l’année, l’état et la population. Cependant, l’information spatiale n’est pas explicitement inclue dans la table (vous n’avez que le nom des états), vous ne pouvez donc pas effectuer d’analyse centrographique. Il faut donc trouver une donnée qui enregistre la géométrie des états.\nLes jeux de données proposés par natural earth permettent de récupérer la géométrie des états. On peut récupérer la donnée directement sous R via le package rnaturalearth. Une fois les données récupérées, on les projette en NAD83 (le référentiel métrique des USA, équivalent de notre lambert93).\n\n# Récupérer les états des USA (1:50m scale)\nstates &lt;- ne_states(country = \"United States of America\", returnclass = \"sf\")\n\n# Pour le détail de la projection\nst_crs(states)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\n\n\n\n\n\n\nInstructions\n\n\n\n\nRécupérer la donnée avec rnaturalearth.\n\n(bis) Dans le cas où rnaturalearth ne fonctionnerait pas, vous pouvez télécharger la donnée ici. Pour lire une donnée spatiale on utilise le package sf avec la fonction read_sf() qui s’utilise d’une façon similaire à readr::read_csv().\n\nConvertissez la donnée en NAD83 (EPSG:5070).\n\nPour convertir un objet sf dans un autre système de projection, on utilise la fonction sf::st_transform().\n\nstates &lt;- st_transform(states, crs = 5070)\n\n\n\nCode\n# Dans le cas où rnaturalearth ne fonctionnerait pas :\nstates &lt;- read_sf(\"data/src/states.gpkg\")\nstates &lt;- st_transform(states, crs = 5070)\n\n\n\n\n\n\n\n\n\n\nRappel\n\n\n\nÀ chaque fois que vous voyez un nouveau package vous devez l’installer et le charger.\nPensez à inscrire les fonctions library() en tête de votre script et pas en plein milieu.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nPourquoi doit-on convertir la donnée spatiale dans un référentiel métrique ?",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Analyse centrographique</span>"
    ]
  },
  {
    "objectID": "01_points/semi_points.html#pré-traitement-des-données",
    "href": "01_points/semi_points.html#pré-traitement-des-données",
    "title": "2  Analyse centrographique",
    "section": "2.3 Pré-traitement des données",
    "text": "2.3 Pré-traitement des données\n\n2.3.1 Filtrage des états\n\n\n\n\n\n\nInstructions\n\n\n\nSupprimer l’Alaska et Hawaii dans les deux jeux de données.\n\n\nCode\nto_remove &lt;- c(\"Hawaii\", \"Alaska\")\ndt &lt;- filter(dt, !state %in% to_remove)\nstates &lt;- filter(states, !name %in% to_remove)\n\n# Équivalent à (moins élégant) :\ndt &lt;- filter(dt, state != \"Hawaii\", state != \"Alaska\")\nstates &lt;- filter(states, name != \"Hawaii\", name != \"Alaska\")\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nPourquoi les supprime-t-on ?\n\n\n\n\n2.3.2 Calcul des centroïdes des états\nLe code ci-dessous nécessite les packages dplyr et sf (permet de manipuler des données spatiales). Les fonctions commençant par st_ sont issues du package sf.\n\nstate_centroids &lt;-\n    # Générer les centroïdes\n    st_centroid(states) |&gt;\n    # Extraire les coordonnées\n    mutate(\n        x = st_coordinates(geometry)[,1],\n        y = st_coordinates(geometry)[,2]\n    ) |&gt;\n    # Convertir en data.frame standard\n    st_drop_geometry() |&gt;\n    # Sélectionner uniquement les variables d'intérêt\n    select(name, x, y)\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nPourquoi calcule-t-on le centroïde des états ?\n\n\n\n\n2.3.3 Jointure des données\n\n\n\n\n\n\nInstructions\n\n\n\nJoindre les deux jeux de données. Référez-vous à la Section 5.1.5 pour les jointures.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nPourquoi fait-on cela ?",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Analyse centrographique</span>"
    ]
  },
  {
    "objectID": "01_points/semi_points.html#application-de-la-méthode",
    "href": "01_points/semi_points.html#application-de-la-méthode",
    "title": "2  Analyse centrographique",
    "section": "2.4 Application de la méthode",
    "text": "2.4 Application de la méthode\nLe centre de gravité (ou barycentre ou point moyen) d’un nuage de point (Equation 2.1). Il s’agit d’une simple moyenne.\n\\[\n(\\bar{x}, \\bar{y}) = \\left(\\frac{1}{N}\\sum_{i = 1}^{N}x_i, \\quad \\frac{1}{N}\\sum_{i = 1}^{N}y_i\\right)\n\\tag{2.1}\\]\nSous R, cela revient à calculer la moyenne des :\n\nLongitudes (mean(x))\nLatitudes (mean(y)).\n\nLe centre de gravité pondéré par la variable \\(z\\), \\(\\bar{x}_z\\) Equation 2.2.\n\\[\n(\\bar{x}_z, \\bar{y}_z) = \\left(\\frac{\\sum_{i = 1}^{N}z_ix_i}{\\sum^{N}_{i=1}z_i},\n\\frac{\\sum_{i = 1}^{N}z_iy_i}{\\sum^{N}_{i=1}z_i}\\right)\n\\tag{2.2}\\]\nSous R, cela revient à calculer la moyenne pondérée des :\n\nLongitudes : (sum(population * x) / sum(population))\nLatitudes : (sum(population * y) / sum(population))\n\nLa distance standard non pondérée (Equation 2.3).\n\\[\n\\text{SD} = \\sqrt{\\text{var}(x) +  \\text{var}(y)} =\n\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(x_i - \\bar{x})^2 + \\frac{1}{N}\\sum_{i=1}^{N}(y_i - \\bar{y})^2}\n\\tag{2.3}\\]\nSous R, on écrira : sqrt(var(x) + var(y))\nLa distance standard pondérée des \\(x\\) et \\(y\\) par la variable \\(z\\) (Equation 2.4).\n\\[\n\\text{SD}_z = \\sqrt{\\frac{\\sum_{i=1}^{N}z[(x_i - \\bar{x}_z)^2 + (y_i - \\bar{y}_z)^2]}{\\sum^{N}_{i=1}z_i}}\n\\tag{2.4}\\]\nSous R, on écrira : sqrt(sum(z * ((x - mean(x_pond))^2 + (y - mean(y_pond))^2)) / sum(z))\n\n\n\n\n\n\nInstructions\n\n\n\n\nCalculer le centre de gravité non pondéré des états avec sa distance standard. Utilisez le jeu de données des centroïdes des états (state_centroids). Le résultat doit être un data.frame d’une seule ligne avec trois variables : \\(\\bar{x}\\), \\(\\bar{y}\\) et \\(\\text{SD}\\). Vous utiliserez la fonction dplyr::summarise().\nCalculer le centre de gravité des états pondéré par la population avec sa distance standard pour toutes les années depuis 1790. Utilisez le jeu de données issu de la jointure entre les centroïdes des états (state_centroids) et celui issu du filtrage des données. Le résultat doit être un data.frame avec quatre variables : l’année, \\(\\bar{x}_z\\), \\(\\bar{y}_z\\) et \\(\\text{SD}_z\\). Vous utiliserez les fonctions group_by() et summarise() du package dplyr.\n\nAu final, vous aurez donc deux jeux de données :\n\nUn d’une seule ligne contenant le centre de gravité non pondéré et sa distance standard.\nUn contenant, pour chaque année, le centre de gravité pondéré par la population et sa distance standard pondérée.\n\n\n\n\n\n\n\n\n\nLes packages pour l’analyse centrographique\n\n\n\n\n\nJe vous demande d’écrire les formules vous même pour vous entraîner. Sachez qu’il existe également des packages qui intègrent des fonctions pour ce genre d’analyse :\n\naspace\n\nFonctions : nombreuses fonctions, on peut réaliser l’ensemble de ce qu’il est possible de faire en analyse centrographique.\nPoints forts : bien pour contrôler dans le détail l’analyse.\nPoints faible : moins user-friendly que sfcentral, pas intégré à sf.\n\nsfcentral :\n\nFonctions : indicateurs de centralité, distance standard (boîte (2D, 3D), cercle), ellipse de distribution directionnelle.\nPoints forts : récent (donc moderne), adapté au tidyverse (e.g. dplyr)\nPoint faible : récent (donc peu mature)\n\n\n\n\n\n\n2.4.1 Cartographie des résultats\n\n2.4.1.1 Analyse non-pondérée\n\n\n\n\n\n\nInstructions\n\n\n\nCartographiez le centre non pondéré des États-Unis avec sa distance standard avec le package ggplot2 (c.f. Section 7.2 pour les graphs avec ggplot2 et Section 8.1 pour la carto, Attention nouveau package).\nVous aurez les couches suivantes :\n\nFond de carte : les USA (geom_sf())\nLe centroïdes des états (geom_point())\nLe centre non pondéré (geom_point())\nLa distance standard (ggforce::geom_circle()). Attention nouveau package\n\nVous vous appuierez sur le code ci-dessous. Vous aurez sans-doute à changer le nom des jeux de données et des variables :\n\nmap_unpondered &lt;- ggplot() +\n  # [ Couche des états ]\n  geom_sf(data = states) + # Le jeu de données spatiales brute\n  # [ La distance standard ]\n  ggforce::geom_circle(\n    data = center_unpondered, # votre jeu de données non-pondéré\n    aes(\n      x0 = c_x, # La moyenne des x\n      y0 = c_y, # La moyenne des y\n      r = c_sd  # la distance standard\n    ),\n    # Symbologie\n    fill = \"red\", alpha = 0.1, inherit.aes = FALSE\n  ) +\n  # [ Le centroïde des états ]\n  geom_point(\n    data = state_centroids, # Le jeu de données contenant les centroïde\n    aes(\n      x = x, # Les x\n      y = y  # Les y\n    ),\n    # Symbologie\n    color = \"grey\"\n  ) +\n  # [ Le centre moyen pondéré ]\n  geom_point(\n    data = center_unpondered, # Le jeu de données non-pondéré\n    aes(\n      x = c_x, # La moyenne des x\n      y = c_y  # La moyenne des y\n    ),\n    # Symbologie\n    color = \"black\", shape = 21, fill = \"red\", size = 3\n  ) +\n  # Titre, labels des axes, sources et réalisation\n  labs(\n    title = \"Titre\",\n    subtitle = \"Sous-titre\",\n    x = \"\",\n    y = \"\",\n    caption = \"Données : .... Réalisation: ...\"\n  ) +\n  # Theme\n  theme_minimal()\nmap_unpondered\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.1.2 Analyse pondérée\n\n\n\n\n\n\nInstructions\n\n\n\nCartographiez le centre pondéré de la population des États-Unis depuis 1970 et sa distance standard avec le package ggplot2.\nCréez une nouvelle carte sur la base de l’ancienne. Il vous faudra “juste” changer certains jeux de données et nom de variables.\nVous conserverez le centre non-pondéré pour comparer.\nInterprétez la carte.\n\n\n\n\n\n\n\n\nInstructions\n\n\n\nLes distances standards ainsi représentées sont peu lisibles. Retirez cette couche de la carte et créez un graphique en ligne pour montrer l’évolution de la distance standard depuis 1970. Utilisez la fonction geom_line().\n\n# Conversion en km des distances standards\ncenter_pondered &lt;- mutate(center_pondered, cw_sd_km = cw_sd/1000)\ncenter_unpondered &lt;- mutate(center_unpondered, c_sd_km = c_sd/1000)\n\npond_sd_line &lt;- ggplot(center_pondered, aes(x = year, y = cw_sd_km, color = year)) +\n  # [ Ligne ]\n  geom_line() +\n  # [ Points ]\n  geom_point() +\n  # [ Ligne horizontale indiquant la distance standard non-pondérée ]\n  geom_hline(\n    yintercept = center_unpondered$c_sd_km, color = \"red\"\n  ) +\n  # [ Label de la ligne ]\n  annotate(\n    \"text\",\n    x = min(center_pondered$year) + 50,\n    y = center_unpondered$c_sd_km + 50,\n    label = \"Distance standard non-pondérée\",\n    color = \"red\"\n  ) +\n  labs(x = \"\", y = \"Distance Standard (km)\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\npond_sd_line\n\n\n\n\n\n\n\n\nEnsuite, combinez la carte et le graph nouvellement créé au moyen de package patchwork. Utilisez la fonction wrap_plots() (c.f. Section 7.2.4).\n\n\n\n\n\n\n\n\nInstructions (bonus)\n\n\n\n\n\nRegardez la distribution des années.\n\nQue pouvez-vous dire du pas de temps ?\nQuel impact cela a-t-il sur la cartographie ?\nComment faire pour pallier ce problème ?\n\nModifier la variable year (utilisez la fonction plyr::round_any()). Ensuite, il vous faudra agréger les données.\n\n\n\n\n\n2.4.1.3 Cartographie animée\nSous R, on peut facilement animer un graph ggplot2 en utilisant le package gganimate. Le rendu est particulièrement parlant pour l’analyse centrographique temporelle.\n\n\n\n\n\n\nInstructions\n\n\n\nCréez une carte avec ggplot2 les couches suivantes :\n\nFond de carte des USA\nCentres pondérés de la population\nDistance standard pondérée de la population\n\nAppuyez-vous sur les cartes précédentes. Ajoutez les lignes suivantes à votre code ggplot2 :\n\n# Convertissez l'année en facteur dans votre tableau des centres pondérés\ncenter_pondered &lt;- mutate(center_pondered, year = as.factor(year))\n\nanim &lt;- ggplot() +\n    # ... votre code\n    labs(\n        title = \"Centre pondéré de la population : {closest_state}\",\n        x = \"\", y = \"\"\n    ) +\n    transition_states(year) +\n    shadow_mark(\n        past = TRUE,\n        alpha = 0.5,\n        colour = \"red\",\n        # l'argument exclude_layer vous permet de supprimer des couches de votre\n        # objet ggplot pour les années passées. Le chiffre indiquent l'ordre\n        # d'apparition des couches.\n        # exclude_layer = c(3, 4)\n    )\n\nPuis rendez l’animation :\n\nanimate(\n    anim, # votre object animation\n    duration = 10,\n    fps = 20,\n    width = 800,\n    height = 500,\n    renderer = gifski_renderer(\n        \"figures/weighted_center.gif\" # le nom de votre anim\n    )\n)\n\n\n\nLa Figure 2.1 donne un exemple de rendu. Vous pouvez modifier votre code pour aboutir à un rendu similaire.\n\n\n\n\n\n\nFigure 2.1: Centre moyen pondéré de la population des États-Unis depuis 1790 (United States Census Bureau, 2025)",
    "crumbs": [
      "Travaux dirigés",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Analyse centrographique</span>"
    ]
  },
  {
    "objectID": "DM01_centro/dm01_centro.html",
    "href": "DM01_centro/dm01_centro.html",
    "title": "3  DM01 : analyse centrographique",
    "section": "",
    "text": "Rendu : lundi 9 mars avant 18h. Depôt sur Moodle.\nÀ l’échelle de l’unité urbaine Brestoise, vous décrirez et comparerez la distribution spatiale moyenne des populations de trois catégories socio-professionnelles différente (au choix). Vous ne prendrez en compte ni l’âge ni le genre.\nVotre analyse sera réalisée au niveau des IRIS. Vous conduirez une analyse de A à Z, aussi, vous devrez :\n\nRécupérer les données\nPrétraiter les données\nAnalyser les données\nInterpréter les résultats\n\n\n\n\n\n\n\nRendu\n\n\n\n\nUn document pdf structuré et bien mise en page documentant votre travail. Si vous voulez écrire un document markdown ou quarto, c’est également envisageable, à vous de voir. Si cela vous dit, vous me fournirez le fichier .html ou .pdf découlant de la compilation de votre fichier md ou qmd1.\n\nÀ ne pas faire :\n\nInclure ou commenter du code (l’aspect technique n’est pas évalué dans ce document)\nInclure un graphique, une carte ou un tableau sans y faire référence dans le texte.\n\nÀ faire :\n\nToujours définir les concepts que vous employez.\nAdopter une structure claire adaptée à votre travail.\nMise en page :\n\nTable des matières\nTitre, noms, etc.\nPagination\n\n\n\nVotre dossier de travail (scripts, dossiers data, figures, etc.). Votre script R doit être reproductible et doit intégrer l’ensemble de vos traitements.\n\n\n\n1 Je considère les documents markdown ou quarto comme des documents de mise en forme. Aussi, je ne regarderai pas votre fichier source md ou qmd mais bien votre script R si vous décidez de passer par ce type de document.\n\n\n\n\n\nBarème /20\n\n\n\nPartie R (3 pts) :\n\nStructure du projet, organisation du script, commentaires, etc. (2 pts)\nReproductibilité du script : quand je ferai tourner le script, il ne doit pas y avoir d’erreur. (1 pts)\n\nPartie cartographie, graphs (4 pts) :\n\nSémiologie graphique. (3 pts)\nSource, Auteur, Date (SAD). Doit apparaître sur toutes les cartes et tous les graphiques. (1 pts)\n\nTraitements et analyses (13 pts) :\n\nPertinence des données employées et des traitements (3 pts)\nValidité et pertinence et des analyses réalisées (5 pts)\nValidité et pertinence des interprétations (5 pts)\n\nAu regard de ce barème, si vous êtes rigoureux dans l’organisation de votre travail et dans la conception de vos figures, vous avez presque déjà la moyenne.\n\n\n\n\n\n\n\n\nExemple de bons travaux\n\n\n\n\nExemple un\nExemple deux\n\nNe copiez pas la structure de ces travaux aveuglement. Contrairement à ces travaux, vous réaliserez des cartes.",
    "crumbs": [
      "Devoir maison",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>DM01 : analyse centrographique</span>"
    ]
  }
]