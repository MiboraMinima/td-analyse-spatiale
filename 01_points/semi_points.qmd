# Analyse centrographique

L'objectif de ce TD est de mettre en lumière l'intérêt de l'analyse
centrographique pour évaluer des tendances spatio-temporelles. Nous
utilisons l'exemple de la dynamique spatiale de la répartition de la population
des États-Unis depuis 1790.

:::{.callout-tip title="Objectif du TD"}

**Méthode :** Être en mesure d'identifier et de discuter la centralité d'un
phénomène spatial au cours du temps.

**Sur `R` :**

- Charger un jeu de données `.csv`.
- Manipulation de données :
    - Filtrer des données
    - Créer des indicateurs
    - Joindre des tableaux de données
- Visualisation :
    - Cartographie simple
    - Graph de ligne
    - Créer une carte animée
:::

:::{.callout-note title="Méthode"}

Voilà les étapes de l'analyse. Il s'agit d'une démarche classique de résolution
d'une question de recherche à visé **descriptive**.

1. Formulation de la question et de la méthode
2. Identification et collecte des données nécessaires
3. Prépraitement des données
4. Application de la méthode
5. Analyse des résultats
6. Interprétation des résultats

Le TD suit cette démarche.

:::

## Formulation du problème et cadre de l'analyse

**Questionnement :** quelle est la dynamique spatiale de la population des
États-Unis depuis la fin du 18e siècle ? (le questionnement s'intéresse donc à
un processus spatio-temporel)

**Type de démarche :** descriptive. Ici, on ne s'intéresse qu'à la description
du phénomène, il n'est pas question de prouver le pourquoi : il ne s'agit pas de
modélisation à visé explicative.

**Méthode :**

- La méthode d'analyse spatiale qui permet l'identification de la localisation
moyenne d'entités spatiales est l'analyse centrographique. (**dimension
spatial**)
- Pour évoluer la tendance temporelle de cette localisation moyenne, il faut
évaluer cette localisation au cours du temps. (**dimension temporelle**)

Ici, je vous donne la méthode. Il va de soit qu'en dehors du TD, vous devrez
trouvez vous-même les méthodes appropriées à la résolution de votre
questionnement (en lisant la littérature scientifique).

## Données

Pour répondre au questionnement et au vu de la méthode retenue, il faut trouver
une donnée qui enregistre la population des États-Unis à une échelle spatiale
cohérente et sur un pas de temps régulier (pour évaluer la tendance temporelle).
En temps normal, vous devrez trouvez vous-même la donnée (si elle existe), ici
je vous la donne directement.

Le recensement de la population des États-Unis est réalisé pour la première fois
en 1790, conformément à la Constitution américaine, qui exige qu’un dénombrement
de la population soit effectué tous les dix ans. Son objectif initial était
politique : déterminer la représentation de chaque État au Congrès et répartir
l’impôt fédéral selon la population. Très vite, le recensement est aussi devenu
un outil administratif et économique, permettant de connaître la distribution de
la population et l’essor des territoires. Organisé par le Census Bureau, il
constitue aujourd’hui l’une des plus longues séries statistiques au monde.

La donnée est disponible sur le site du [Census
Bureau](https://www.census.gov/library/working-papers/2002/demo/POP-twps0056.html).
Elle est mise à disposition dans un format inexploitable en l'état. Sur
[Kaggle](https://www.kaggle.com/datasets/rolfhendriks/us-population-by-state-comprehensive-data),
on trouve le jeu de données correctement sous un format
*[tidy](https://r4ds.had.co.nz/tidy-data.html)*, c'est la donnée que nous
utiliserons. Le jeu de données dispose de trois variables : `state`, `year` et
`population`.

```{r}
#| code-fold: true
readr::read_csv("data/src/us_population_by_state.csv", show_col_types = FALSE) |>
reactable::reactable(
    searchable = TRUE,
    filterable = TRUE,
    striped = TRUE,
    highlight = TRUE,
    bordered = TRUE,
    defaultPageSize = 10,
    theme = reactablefmtr::nytimes()
  )
```

:::{.callout-note title="Instructions"}
Chargez le jeu de données avec la fonction `readr::read_csv()` (*c.f.*
@sec-io-df). Téléchargez la donnée en cliquant [ici](https://github.com/MiboraMinima/td-analyse-spatiale/raw/refs/heads/main/01_points/data/src/us_population_by_state.csv).
:::

```{r}
#| echo: false
#| output: false

# Installez pacman avant de pouvoir utiliser la fonction p_load()
# install.packages("pacman")
pacman::p_load(
  # Lire et manipuler les données
  readr,
  dplyr,
  glue,
  # Données spatiales et manipulation de données spatiales
  rnaturalearth,
  rnaturalearthdata,
  sf,
  # Visualisation de données
  patchwork,
  gganimate,
  ggplot2,
  ggforce
)

# Rentré le chemin de votre dossier figures
FIG_DIR <- "figures"
# Rentré le chemin de votre dossier data
DATA_DIR <- "data"

# Read pop data
dt <- read_csv(glue("{DATA_DIR}/src/us_population_by_state.csv"))
```

À ce stade vous disposez de presque toutes les données nécessaires : l'année,
l'état et la population. Cependant, l'information spatiale n'est pas
explicitement inclue dans la table (vous n'avez que le nom des états), vous ne
pouvez donc pas effectuer d'analyse centrographique. Il faut donc trouver une
donnée qui enregistre la géométrie des états.

Les jeux de données proposés par [natural
earth](https://www.naturalearthdata.com/) permettent de récupérer la géométrie
des états. On peut récupérer la donnée directement sous `R` via le package
[`rnaturalearth`](https://ropensci.github.io/rnaturalearth/). Une fois les
données récupérées, on les projette en NAD83 (le référentiel métrique des USA,
équivalent de notre lambert93).

```{r}
# install.packages("rnaturalearth")
# install.packages("rnaturalearthdata")
# library(rnaturalearth)
# library(rnaturalearthdata)

# Get US states polygons (1:50m scale)
# Convert to appropriate metric datum :
# NAD83 / Conus Albers Equal Area Projection
states <- ne_states(country = "United States of America", returnclass = "sf") |>
  st_transform(crs = 5070)
```

::: {.callout-warning title="Rappel"}

À chaque fois que vous voyez un nouveau package vous devez l'installer et le
charger.

Pensez à inscrire les fonctions `library()` en tête de votre script et pas en
plein milieu.

:::

:::{.callout-tip title="Question"}
Pourquoi doit-on convertir la donnée spatiale dans un référentiel métrique ?
:::

## Pré-traitement des données

### Filtrage des états

:::{.callout-note title="Instructions"}
Supprimer l'Alaska et Hawaii dans les deux jeux de données.
:::
:::{.callout-tip title="Question"}
Pourquoi les supprime-t-on ?
:::

```{r}
#| echo: false
#| output: false

to_remove <- c("Hawaii", "Alaska")
dt <- filter(dt, !state %in% to_remove)
states <- filter(states, !name %in% to_remove)
```

### Calcul des centroïdes des états

Le code ci-dessous nécessite les packages `dplyr` et
[`sf`](https://r-spatial.github.io/sf/) (permet de manipuler des données
spatiales). Les fonctions commençant par `st_` sont issues du package `sf`.

```{r}
state_centroids <-
    # Générer les centroïdes
    st_centroid(states) |>
    # Extraire les coordonnées
    mutate(
        x = st_coordinates(geometry)[,1],
        y = st_coordinates(geometry)[,2]
    ) |>
    # Convertir en data.frame standard
    st_drop_geometry() |>
    # Sélectionner uniquement les variables d'intérêt
    select(name, x, y)
```

:::{.callout-tip title="Question"}
Pourquoi calcule-t-on le centroïde des états ?
:::

### Jointure des données

:::{.callout-note title="Instructions"}
Joindre les deux jeux de données. Référez-vous à la @sec-join pour les jointures.
:::

:::{.callout-tip title="Question"}
Pourquoi fait-on cela ?
:::

```{r}
#| echo: false
#| output: false

### Calculer les indicateurs de centrographie
data_joined <- left_join(dt, state_centroids, by = c("state" = "name"))
```

## Application de la méthode

**Le centre de gravité** (ou barycentre ou point moyen) d'un nuage de point
(@eq-mean-center). Il s'agit d'une simple moyenne.

$$
(\bar{x}, \bar{y}) = \left(\frac{1}{N}\sum_{i = 1}^{N}x_i, \quad \frac{1}{N}\sum_{i = 1}^{N}y_i\right)
$${#eq-mean-center}

Sous `R`, cela revient à calculer la moyenne des :

- Longitudes (`mean(x)`)
- Latitudes (`mean(y)`).

**Le centre de gravité pondéré** par la variable $z$, $\bar{x}_z$ @eq-mean-center-pond.

$$
(\bar{x}_z, \bar{y}_z) = \left(\frac{\sum_{i = 1}^{N}z_ix_i}{\sum^{N}_{i=1}z_i},
\frac{\sum_{i = 1}^{N}z_iy_i}{\sum^{N}_{i=1}z_i}\right)
$${#eq-mean-center-pond}

Sous `R`, cela revient à calculer la moyenne pondérée des :

- Longitudes : (`sum(population * x) / sum(population)`)
- Latitudes : (`sum(population * y) / sum(population)`)

**La distance standard non pondérée** (@eq-sd-unpondered).

$$
\text{SD} = \sqrt{\text{var}(x) +  \text{var}(y)} =
\sqrt{\frac{1}{N}\sum_{i=1}^{N}(x_i - \bar{x})^2 + \frac{1}{N}\sum_{i=1}^{N}(y_i - \bar{y})^2}
$${#eq-sd-unpondered}

Sous `R`, on écrira  : `sqrt(var(x) + var(y))`

**La distance standard pondérée** des $x$ et $y$ par la variable $z$
(@eq-sd-pondered).

$$
\text{SD}_z = \sqrt{\frac{\sum_{i=1}^{N}z[(x_i - \bar{x}_z)^2 + (y_i - \bar{y}_z)^2]}{\sum^{N}_{i=1}z_i}}
$${#eq-sd-pondered}

Sous `R`, on écrira  : `sqrt(sum(z * ((x - mean(x_pond))^2 + (y - mean(y_pond))^2)) / sum(z))`

:::{.callout-note title="Instructions"}
1. Calculer le centre de gravité non pondéré des états avec sa distance
   standard. Utilisez le jeu de données des centroïdes des états
(`state_centroids`). Le résultat doit être un `data.frame` d'une seule ligne
avec trois variables : $\bar{x}$, $\bar{y}$ et $\text{SD}$. Vous utiliserez la
fonction `dplyr::summarise()` (*c.f.* @sec-agg).
2. Calculer le centre de gravité des états pondéré par la population avec sa
   distance standard pour toutes les années depuis 1790. Utilisez le jeu de
données issu de la jointure entre les centroïdes des états (`state_centroids`)
et celui issu du filtrage des données. Le résultat doit être un `data.frame`
avec quatre variables : l'année, $\bar{x}_z$, $\bar{y}_z$ et $\text{SD}_z$. Vous
utiliserez les fonctions `group_by()` et `summarise()` du package `dplyr`
(*c.f.* @sec-agg).

Au final, vous aurez donc deux jeux de données :

- Un d'une seule ligne contenant le centre de gravité non pondéré et sa distance
standard.
- Un contenant, pour chaque année, le centre de gravité pondéré par la
population et sa distance standard pondérée.
:::

```{r}
#| echo: false
#| output: false

# Unpondered center ............................................................
center_unpondered <- state_centroids |>
  summarise(
    c_x = mean(x),
    c_y = mean(y),
    c_sd = sqrt(var(x) + var(y)),
  )

# Pondered center for each year ................................................
center_pondered <- data_joined |>
  group_by(year) |>
  summarise(
    cw_x = sum(population * x) / sum(population),
    cw_y = sum(population * y) / sum(population),
    cw_sd = sqrt(sum(population * ((x - mean(cw_x))^2 + (y - mean(cw_y))^2)) / sum(population))
  )
```

### Cartographie des résultats

#### Analyse non-pondérée

:::{.callout-note title="Instructions"}
Cartographiez le centre non pondéré des États-Unis avec sa distance standard
avec le package `ggplot2` (*c.f.* @sec-ggplot pour les graphs avec `ggplot2` et
@sec-carto-ggplot pour la carto, **Attention nouveau package**).

Vous aurez les couches suivantes :

- Fond de carte : les USA (`geom_sf()`)
- Le centroïdes des états (`geom_point()`)
- Le centre non pondéré (`geom_point()`)
- La distance standard (`ggforce::geom_circle()`). **Attention nouveau package**

Vous vous appuierez sur le code ci-dessous. Vous aurez sans-doute à changer le
nom des jeux de données et des variables :

```{r}
#| eval: true

ggplot() +
  # [ Couche des états ]
  geom_sf(data = states) + # Le jeu de données spatiales brute
  # [ La distance standard ]
  ggforce::geom_circle(
    data = center_unpondered, # votre jeu de données non-pondéré
    aes(
      x0 = c_x, # La moyenne des x
      y0 = c_y, # La moyenne des y
      r = c_sd  # la distance standard
    ),
    # Symbologie
    fill = "red", alpha = 0.1, inherit.aes = FALSE
  ) +
  # [ Le centroïde des états ]
  geom_point(
    data = state_centroids, # Le jeu de données contenant les centroïde
    aes(
      x = x, # Les x
      y = y  # Les y
    ),
    # Symbologie
    color = "grey"
  ) +
  # [ Le centre moyen pondéré ]
  geom_point(
    data = center_unpondered, # Le jeu de données non-pondéré
    aes(
      x = c_x, # La moyenne des x
      y = c_y  # La moyenne des y
    ),
    # Symbologie
    color = "black", shape = 21, fill = "red", size = 3
  ) +
  # Titre, labels des axes, sources et réalisation
  labs(
    title = "Titre",
    subtitle = "Sous-titre",
    x = "",
    y = "",
    caption = "Données : .... Réalisation: ..."
  ) +
  # Theme
  theme_minimal()
```
:::

#### Analyse pondérée

:::{.callout-note title="Instructions"}
Cartoragphiez le centre pondéré de la population des états-Unis depuis 1970 avec
leur distance standard avec le package `ggplot2`.

Créez un nouveau une nouvelle sur la base de l'ancienne. Il vous faudra "juste"
changer certains jeu de données et nom de variables.

Vous ajouterez le centre non-pondéré pour comparer.

Interprétez la carte.
:::

:::{.callout-note title="Instructions"}
Les distances standards ainsi représentées sont peu lisibles. Retirez cette
couche de la carte et créez un graphique en ligne pour montrer l'évolution de la
distance standard depuis 1970. Utilisez la fonction `geom_line()`.

```{r}
# Conversion en km des distances standards
center_pondered <- mutate(center_pondered, cw_sd_km = cw_sd/1000)
center_unpondered <- mutate(center_unpondered, c_sd_km = c_sd/1000)

pond_sd_line <- ggplot(center_pondered, aes(x = year, y = cw_sd_km, color = year)) +
  # [ Ligne ]
  geom_line() +
  # [ Points ]
  geom_point() +
  # [ Ligne horizontale indiquant la distance standard non-pondérée ]
  geom_hline(
    yintercept = center_unpondered$c_sd_km, color = "red"
  ) +
  # [ Label de la ligne ]
  annotate(
    "text",
    x = min(center_pondered$year) + 50,
    y = center_unpondered$c_sd_km + 50,
    label = "Distance standard non-pondérée",
    color = "red"
  ) +
  labs(x = "", y = "Distance Standard (km)") +
  theme_minimal() +
  theme(legend.position = "none")
pond_sd_line
```

Ensuite, combinez la carte et le graph nouvellement créé au moyen de package
`patchwork`. Utilisez la fonction `wrap_plots()`.
:::

:::{.callout-note title="Instructions (bonus)" collapse="true"}
Regardez la distribution des années.

- Que pouvez-vous dire du pas de temps ?
- Quel impact cela a-t-il sur la cartographie ?
- Comment faire pour pallier ce problème ?

Modifier la variable `year` (utilisez la fonction `plyr::round_any()`). Comme il
faut modifier une variable, vous utiliserez la fonction `mutate()`. Ensuite, il
vous faudra aggrégré les données (*c.f.* @sec-agg).
:::

#### Cartographie animée

Sous R, on peut facilement animer un graph `ggplot2` en utilisant le package
`gganimate`. Le rendu est particulièrement parlant pour l'analyse
centrographique temporelle.

:::{.callout-note title="Instructions"}
Créez une carte avec `ggplot2` les couches suivantes :

- Fond de carte des USA
- Centres pondérés de la population

Ajoutez les lignes suivantes à votre code `ggplot2` :

```{r}
#| eval: false

# Convertissez l'année en facteur dans votre tableau des centres pondérés
center_pondered <- mutate(center_pondered, year = as.factor(year))

anim <- ggplot() +
    # ... votre code
    labs(
        title = "Centre pondéré de la population : {closest_state}",
        x = "", y = ""
    ) +
    transition_states(year) +
    shadow_mark(
        past = TRUE,
        alpha = 0.5,
        colour = "black",
        # l'argument exclude_layer vous permet de supprimer une des couches de votre
        # objet ggplot pour les années passées.
        # exclude_layer = 3
    )
```

Puis rendez l'animation :

```{r}
#| eval: false

animate(
    anim, # votre object animation
    duration = 10,
    fps = 20,
    width = 800,
    height = 500,
    renderer = gifski_renderer(
        "figures/weighted_center.gif" # le nom de votre anim
    )
)
```
:::

La @fig-anim donne un exemple de rendu. Vous pouvez modifier votre code pour
aboutir à un rendu similaire.

![Centre moyen pondéré de la population des États-Unis depuis 1790 (United
States Census Bureau, 2025)](./figures/weighted_center.gif){#fig-anim}

